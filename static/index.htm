<html>

<head>
  <title>INFO 4310 - HW4</title>
  <link href="./style.css" rel="stylesheet" type="text/css">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <style>
    body {
      font-family: 'Barlow', 'Helvetica', sans-serif;
      font-weight: 400;
      margin: 0 0 0 100px;
      padding: 0;
      min-width: 1400px;
      /* overflow-x: scroll;
      overflow-y: hidden;
      overscroll-behavior-x: none; */
    }

    h1 {
      font-weight: 600;
      font-size: 3em;
      margin: 20px 0 0 0;
      padding: 0;
      color: black;
    }

    h2 {
      font-weight: 700;
      font-size: 2em;
      margin: 0;
      padding: 0 0 5px 0;
      color: #3A7C98;
      /* border-bottom: 1px solid #777; */
    }

    h3 {
      font-weight: 700;
      font-size: 1.05em;
      margin: 0;
      padding: 0px 0 15px 0;
      color: #3A7C98;
    }

    h3.withRule {
      border-top: 1px solid #ccc;
      padding-top: 12px;
      margin-top: 15px;
    }

    h3#best {
      font-weight: 800;
      font-size: 1.15em;
      color: #d81289;
    }

    p {
      margin: 0;
      padding: 3px 0;
      line-height: 1.3em;
    }

    p#tagline {
      font-size: 1.1em;
      color: #3A7C98;
      margin: 0;
      padding: 0 0 35 0;
    }

    /* BUTTONS */
    button {
      font-family: 'Barlow', 'Helvetica', sans-serif;
      background-color: #ffffff;
      border: 2px solid #777;
      color: #777;
      border-radius: 20px;
      margin: 0 7px 10px 0;
      padding: 6px 10px 8px 10px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
    }

    /* button[value="cafes"]::before {
      content: "#";
      color: gray;
    }
    .clicked[value="cafes"]::before {
      content: url("logo.png");
      content: "#";
      color: purple;
    }     */

    .clicked {
      background-color: #e3d2fd;
      border: 2px solid #7339D0;
      color: #7339D0;
    }

    button:hover {
      text-decoration: underline dotted;
      text-underline-offset: 3px;
    }

    .clicked:hover {
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    #distance button {
      width: 80px;
    }

    #category button {
      width: 125px;
    }

    #category {
      display: flex;
      flex-direction: column;
    }

    #category select {
      width: 200px;
      height: 2em;
    }

    #category label {
      margin-top: .5em;
      margin-bottom: 0.1em;
    }

    button#selectAllButton,
    button#resetButton {
      margin: 0 0 12px 0;
      padding: 0;
      border: 0;
      font-size: .95em;
      font-weight: 500;
      color: #3A7C98;
    }

    #selectAllButton:hover,
    #resetButton:hover {
      background-color: white;
      border: 0;
      border-radius: 0;
      text-decoration: underline dotted;
      text-underline-offset: 3px;
    }

    /* CONTAINERS */
    .flex-container {
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      flex-wrap: nowrap;
    }

    div.filterColumn {
      margin: 0;
      padding: 10px 35px 10px 0;
      min-width: 300px;
      max-width: 300px;
    }


    div.mapColumn {
      margin: 0;
      padding: 10px 35px 10px 0;
    }

    div.filterButtonContainer {
      height: calc(100vh - 170px);
      /* overflow-y: scroll; */
    }

    div.restaurant-list-info {
      max-width: 400px;
      min-width: 300px;
      margin: 0;
      padding: 145px 20px 0 0;
    }

    .restaurant-list {
      height: calc(100vh - 240px);
      margin: 0;
      padding: 5px 35px 10px 10px;
      overflow-y: scroll;
    }

    .restaurant-list a {
      text-decoration: none !important;
      color: inherit;
    }

    .restaurant-item {
      margin-bottom: 10px;
    }

    div.mapColumn {
      overflow-x: scroll;
      overflow-y: hidden;
    }

    .tick line {
      visibility: hidden;
    }

    .tick text {
      font-size: 16px
    }

    .domain {
      visibility: hidden;

    }
  </style>

</head>

<body>
  <div>
    <h2>EMPLOYMENT RATE</h2>
    <h1 style="margin-bottom: 1.25em;">In 2022, the employment rate for the disabled population in the United States is
      <span id=usa_p_estimate style="color: #3A7C98">13.9%</span>.
    </h1>
  </div>

  <div class="flex-container">

    <!--  ---------------
              FILTERS 
          --------------- -->
    <div class="filterColumn">
      <h10>FILTERS</h10>

      <div class="filterButtonContainer">
        <!-- CATEGORY FILTER-->
        <h3 class="withRule">POPULATION CHARACTERISTICS</h3>
        <button id="selectAllButton" value="selectAll">SELECT ALL</button>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<button
          id="resetButton" value="reset">CLEAR ALL</button>
        <div id="category">
          <label for="mapType">Map Type:</label>
          <select id="mapType" name="mapType">
            <option value="0" selected>With or Without Disability</option>
            <option value="1">With Disability</option>
            <option value="2">Without Disability</option>
          </select>

          <label for="gender">Gender:</label>
          <select id="gender" name="gender">
            <option value="0" selected>Male or Female</option>
            <option value="1">Males</option>
            <option value="2">Females</option>
          </select>

          <label for="disabilityType">Disability Type:</label>
          <select id="disabilityType" name="disabilityType">
            <option value="1" selected>Any Disability</option>
            <option value="2">Visual Disability</option>
            <option value="3">Hearing Disability</option>
            <option value="4">Ambulatory Disability</option>
            <option value="5">Cognitive Disability</option>
            <option value="6">Self-Care Disability</option>
            <option value="7">Independent Living Disability</option>
          </select>

          <label for="age">Age:</label>
          <select id="age" name="age">
            <option value="0" selected>All Ages</option>
            <option value="5">Ages 4 and under</option>
            <option value="6">Ages 5-15</option>
            <option value="1">Ages 16-20</option>
            <option value="2">Ages 21-64</option>
            <option value="3">Ages 16-64</option>
            <option value="4">Ages 18-64</option>
            <option value="7">Ages 65-74</option>
            <option value="9">Ages 65+</option>
            <option value="8">Ages 75+</option>
          </select>

          <label for="race">Race:</label>
          <select id="race" name="race">
            <option value="0" selected>All races</option>
            <option value="1">White</option>
            <option value="2">Black/African American</option>
            <option value="3">Native American or Alaska Native</option>
            <option value="4">Asian</option>
            <option value="5">Some other race(s)</option>
          </select>

          <label for="education">Education:</label>
          <select id="education" name="education">
            <option value="0" selected>All education levels</option>
            <option value="1">Less than a high school education</option>
            <option value="2">A high school diploma or equivalent</option>
            <option value="3">Some college/associates degree</option>
            <option value="4">A BA degree or higher</option>
          </select>

          <label for="hispanic">Hispanic:</label>
          <select id="hispanic" name="hispanic">
            <option value="0" selected>Regardless of ethnicity</option>
            <option value="1">Hispanic</option>
            <option value="2">Non-Hispanic</option>
          </select>

          <label for="value">Value:</label>
          <select id="value" name="value">
            <option value="percentage" selected>Percentage</option>
            <option value="number">Number</option>
          </select>




        </div>

      </div>
    </div>


    <!--  ---------------
                MAP 
          --------------- -->
    <div class="mapColumn">
      <h10>MAPS</h10>
      <h3 class="withRule">EMPLOYMENT RATE ESTIMATE (2022)</h3>
      <h3 style="color: black">The employment rate for non-institutionalized,
        <span id="gender">male or female</span>,
        with <span id="disabilityType">any</span> disability,
        <span id="age">all ages</span>,
        <span id="race">all races</span>,
        <span id="hispanic">regardless of ethnicity</span>,
        with <span id="education"></span> in the Unites States is <span id="dynamic_p_estimate">13.9%</span> in 2022.
      </h3>
      <div id="restaurant-hover" class="restaurant-hover"></div>
      <svg id="svgMap" width="1000" height="700" top="10">
      </svg>
    </div>

  </div>


  <!-- ==================
        MAP SCRIPT
    =================== -->
  <script id="map">
    const svgMap = d3.select("#svgMap");
    const width = svgMap.attr("width");
    const height = svgMap.attr("height");
    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/ckttxzrvq0s4i18l4he5vtltt/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`

    //set up colors 
    const selectedColor = "#7339D0";
    const greyedoutColor = "#A5A0AC";

    //TODO actually switch this when we swap table type
    let plottingPrevalenceTable = true;


    const requestMapData = async () => {

      //initialize dict with column values
      let columnValues = {
        mapType: 0,
        gender: 0,
        disabilityType: 1,
        age: 0,
        race: 0,
        education: 0,
        hispanic: 0,
        value: 0 //TODO: delete this? I think it's a bit redundant
      };



      //state data (filter based on selected)
      let statesAll = await d3.csv("./acs_prevalence.csv", d3.autoType);
      let statesData = statesAll.filter(function (row) {
        return (
          row.gender === columnValues.gender
          &&
          row.disability_type === columnValues.disabilityType
          &&
          row.age === columnValues.age &&
          row.race === columnValues.race &&
          row.education === columnValues.education &&
          row.hispanic === columnValues.hispanic
        )
      }); //this is used for filtering

      // console.log(statesData);
      //setting up selections to track selections for prevalence 
      //TODO: need to adapt to different datasets
      let prevalenceColumns = ["mapType", "gender", "disabilityType", "age", "race", "education", "hispanic", "values"];
      prevalenceColumns.forEach((d) => {

        d3.select(`select#${d}`)
          .on("change", function () {
            columnValues[d] = Number(d3.select(this).property("value"));
            //console.log(`${d} changed, logging column values:`, columnValues);

            updateData();
          });
      })

      //these are columns that affect text
      let textColumns = ["gender", "disabilityType", "age", "race", "education", "hispanic"]


      //load map data and match up state names to codes
      const us = await d3.json("./us.json");
      const code_names = await d3.csv("./state-name-codes.csv", d3.autoType);


      // 3b. Generate the data structures we will need
      var stateDict = {}   // stateID ===> stateData

      code_names.forEach(d => {
        stateDict[d.state_code] = d.state_name;
      });

      var dataDict = {}
      statesData.forEach(d => {
        dataDict[d.state] = { n_estimate: d.n_estimate, p_estimate: d.p_estimate }
      });
      //console.log("dataDict", dataDict);

      //create list of p_estimates to calculate extent
      let all_p_estimates = [];

      for (const key in dataDict) {
        if (dataDict.hasOwnProperty(key)) {
          const values = dataDict[key];
          all_p_estimates.push(values.p_estimate);
        }
      }

      //console.log("all_p_estimates", all_p_estimates);
      //updates text for all disability text for usa (this assumes the first selection is everyone with disability)
      d3.select("span#usa_p_estimate").text(`${dataDict["the United States"].p_estimate}%`);

      var states = topojson.feature(us, us.objects.states);     // List of state outlines to fill
      var statesMesh = topojson.mesh(us, us.objects.states);    // 'Mesh' of all outlines put together for a stroke

      //add names to each state
      states.features.forEach(d => {
        d.name = stateDict[d.id]
      });


      // MAP
      const projection = d3.geoMercator() //geoAlbersUsa() to see alaska
        .scale(1 / (2 * Math.PI))
        .translate([0, 0]);

      let render = d3.geoPath(projection);

      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = svgMap.append("g")
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      var data = []; //TODO: update this when data changes, colorScale will also be automatically updated
      let colors = d3.schemeBlues[9];
      let colorScaleState = d3.scaleQuantize(d3.extent(all_p_estimates), colors);

      let statePaths = svgMap.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)  // debugging
        .attr("d", render)
        .attr("fill", d => {
          if (d.name == "Virgin Islands") return "none" //we don't have data for Virgin Islands
          else return colorScaleState(dataDict[d.name].p_estimate)
        })
        .attr("opacity", 0.8)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState);

      let momesh = svgMap.append("path")
        .attr("class", "mouseover outline")
        .style("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .attr("d", "");

      //Mouseover interaction
      let tooltipWidth = 250;
      let tooltipHeight = 45;

      let tooltip = svgMap.append("g")
        .attr("class", "tooltip")
        .attr("transform", `translate(${20},20)`)
        .attr("visibility", "hidden");

      let box = tooltip.append("rect")
        .attr("fill", "white")
        .attr("opacity", 0.8)
        .attr("x", 0)
        .attr("y", 10)
        .attr("width", 110)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 15);
      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 35);

      var state_datum = states.features[0]; //use this to store selected SVG element to use for zooming, initialized with first feature

      function mouseEntersState() {
        // Make tooltip visible
        tooltip.style("visibility", "visible")

        let state = d3.select(this);
        state_datum = state.datum();

        let stateID = state_datum.id;

        txt.text(state_datum.name);
        txt2.text(dataDict[state_datum.name].p_estimate + "%");

        let bounds = render.bounds(state.datum());
        let xPos = (state_datum.name === "Alaska") ? bounds[0][0] : (bounds[0][0] + bounds[1][0]) / 2;
        let yPos = bounds[1][1];

        tooltip.attr("transform", `translate(${xPos},${yPos})`);

        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });

        momesh.datum(mo).attr("d", render)

      }

      function mouseLeavesState() {

        // Hide when you leave a state
        tooltip.style("visibility", "hidden");

        let state = d3.select(this);

        // Reset old style mouseover stroke
        // state.attr("stroke","none")
        //      .attr("stroke-width", 0);
        // }

        // hiding the mouseover mesh
        momesh.attr("d", "");

      }
      var zoom = d3.zoom()
        .scaleExtent([1 << 12, 1 << 20])
        .on("zoom", ({ transform }) => zoomed(transform));


      //centerLocation
      let centerCoordinates = {
        latitude: 41.4925,
        longitude: -99.9018
      };

      svgMap
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(- 1 << 12)
          .translate(...projection([centerCoordinates.longitude, centerCoordinates.latitude]))
          .scale(-1)
        )
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {
        // console.log("regular projection", projection([42.36541856, -71.05688332]))

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);


          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);

        });

        projection
          .scale(transform.k / (2 * Math.PI))
          .translate([transform.x, transform.y]);

        render = d3.geoPath(projection);

        //update state outlines
        statePaths.attr("d", render);

        //update hover path location
        momesh.attr("d", render);

        //update text location
        let bounds = render.bounds(state_datum);
        let xPos = (state_datum.name === "Alaska") ? bounds[0][0] : (bounds[0][0] + bounds[1][0]) / 2;
        let yPos = bounds[1][1];
        tooltip.attr("transform", `translate(${xPos},${yPos})`);

      };


      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      //calls update on filters when selections are changed
      function updateData() {


        statesData = statesAll.filter(function (row) {
          return (
            row.gender === columnValues.gender
            &&
            row.disability_type === columnValues.disabilityType
            &&
            row.age === columnValues.age &&
            row.race === columnValues.race &&
            row.education === columnValues.education &&
            row.hispanic === columnValues.hispanic
          )
        });
        //console.log(statesData);



        //console.log("dataDict before", dataDict)
        //refilters the states to be displayed
        statesData.forEach(d => {
          dataDict[d.state] = { n_estimate: d.n_estimate, p_estimate: d.p_estimate }
        });
        //console.log("dataDict after", dataDict)

        let goodData;
        if (plottingPrevalenceTable) {
          let dedupedStatesData = statesData.reduce((accumulator, currentLocation) => {
            if (!accumulator.tempLocations.includes(currentLocation.state)) {
              accumulator.tempLocations.push(currentLocation.state); // Add id to tempIds to track uniqueness
              accumulator.unique.push(currentLocation); // Add the current item to the unique list
            }
            return accumulator;
          }, { tempLocations: [], unique: [] }).unique;
          goodData = dedupedStatesData;
        } else {
          goodData = unstackDataset(statesData);
        }

        updateTableRows(goodData);

        //TODO: should we rescale to show more color ranges, or keep for consistency?
        all_p_estimates = [];

        // reevaluate all p_estimates
        for (const key in dataDict) {
          if (dataDict.hasOwnProperty(key)) {
            const values = dataDict[key];
            // Add value2 to the allValue2s array
            all_p_estimates.push(values.p_estimate);
          }
        }

        // console.log("usa p est: ", dataDict["the United States"])


        colorScaleState = d3.scaleQuantize(d3.extent(all_p_estimates), colors);

        statePaths.attr("fill", d => {
          if (d.name == "Virgin Islands") return "none" //we don't have data for Virgin Islands
          else return colorScaleState(dataDict[d.name].p_estimate)
        })

        //dynamically fill description spans
        textColumns.forEach(d => {
          let value = key[d][Number(columnValues[d])];
          d3.select(`span#${d}`).text(value);
        })
        d3.select("span#dynamic_p_estimate").text(`${dataDict["the United States"].p_estimate}%`);


      }

      updateData();

    }

    requestMapData();

    // ---------------
    // HELPER FUNCTIONS
    // ---------------

    //key to match numbers to names, used to dynamically populate descriptions
    let key = {
      gender: {
        0: 'male or female',
        1: 'male',
        2: 'female'
      },
      disabilityType: {
        1: 'any',
        2: 'visual',
        3: 'hearing',
        4: 'ambulatory',
        5: 'cognitive',
        6: 'self-care',
        7: 'independent living'
      },
      age: {
        0: 'all ages',
        1: 'ages 4 and under',
        2: 'ages 5-15',
        3: 'ages 16-20',
        4: 'ages 21-64',
        5: 'ages 16-64',
        6: 'ages 18-64',
        7: 'ages 65-74',
        8: 'ages 65+',
        9: 'ages Ages 75+'
      },
      race: {
        0: 'all races',
        1: 'White',
        2: 'Black/African American',
        3: 'Native American or Alaska native',
        4: 'Asian',
        5: 'some other race(s)'
      },
      education: {
        0: 'all education levels',
        1: 'less than a high school education',
        2: 'a high school diploma or equivalent',
        3: 'some college/associates degree',
        4: 'a BA degree or higher'
      },
      hispanic: {
        0: 'regardless of ethnicity',
        1: 'Hispanic',
        2: 'non-Hispanic'
      }
    }

    //makes sure element shows up within bounds
    function elementLocation(mouseX, mouseY, elementWidth, elementHeight, boundaryX, xMargin, yMargin) {

      let xPos = mouseX + xMargin;
      let yPos = mouseY - yMargin - elementHeight;

      if ((xPos + elementWidth) > boundaryX) {
        xPos = mouseX - xMargin - elementWidth
      }
      if (yPos < 0) {
        yPos = mouseY - yMargin
      }

      return { x: xPos, y: yPos };

    }



  </script>

  <!-- ==================
        TABLE
    =================== -->
  <svg id="prevalenceTable" height="2000" width="1200">

  </svg>
  <!-- ==================
        TABLE SCRIPT
    =================== -->
  <script>

    // --- We are going to make the table
    // Create the <svg> where it lives or select it
    // Make the extra g tags for annotations and lines and labels etc
    // Call updateTableRows on your data array to fill in each row

    // --- Someone pressed a sorting button
    // Re-sort the data array based on some criteria
    //  (e.g. now the lowest p_est is first instead of alphabetical by state)
    // Call updateTableRows again on the newly sorted dataset

    // -- Someone changed ANYTHING else in the filter panel etc
    // Just make sure that your data array has the right stuff in it
    // Then call updateTableRows
    const empSVG = d3.select("svg#prevalenceTable");
    const empSVGWidth = empSVG.attr("width");
    const empSVGHeight = empSVG.attr("height");
    const empSVGMargin = { top: 40, right: 30, bottom: 50, left: 130 };
    const empChartWidth = empSVGWidth - empSVGMargin.left - empSVGMargin.right;
    const empChartHeight = empSVGHeight - empSVGMargin.top - empSVGMargin.bottom;

    const rowHeight = 30;

    const tableCategories = ["Location", "Estimate (%)", "90% MOEp", "Estimate (number)", "90% MOEn", "Base Population", "Sample Size"];
    const tableGroups = ["Location", "Percent", "Number", "Base Population", "Sample Size"];


    const locationStart = 0;
    const locationWidth = 175;

    const pEstimateStart = locationStart + locationWidth;
    const pEstimateWidth = 80;

    const pMoeStart = pEstimateStart + pEstimateWidth;
    const pMoeWidth = 80;

    const nEstimateStart = pMoeStart + pMoeWidth;
    const nEstimateWidth = 100;

    const nMoeStart = nEstimateStart + nEstimateWidth;
    const nMoeWidth = 80;

    const populationStart = nMoeStart + nMoeWidth;
    const populationWidth = 120;

    const sampleStart = populationStart + populationWidth;
    const sampleWidth = 90;

    const thousandFormatter = d3.format(",");
    const floatFormatter = d3.format(".1f");

    function customFormatter(value) {
      const formattedVal = d3.format(",")(value);
      return `±${formattedVal}`;
    }

    const barMargin = 5;
    const endCircleRadius = 10;

    const mouseOverLabelBoxHeight = 20;
    const mouseOverLabelBoxWidth = 75;

    const headerHeight = 50;
    const tableFontSize = 12;
    const textMargin = 10;

    const closeHeight = 30;
    const closeWidth = 40;
    const closeInnerBoxHeight = 20;
    const xMargin = 3;

    const tableSpacingDict = {};

    // syntax for this dict, value 0 is start pos, value 1 is width, value 2 is header name, value 3 is formatter for displaying the value
    tableSpacingDict[tableCategories[0]] = [locationStart, locationWidth, "state", null];
    tableSpacingDict[tableCategories[1]] = [pEstimateStart, pEstimateWidth, "p_estimate", null];
    tableSpacingDict[tableCategories[2]] = [pMoeStart, pMoeWidth, "p_estimate_moe", customFormatter];
    tableSpacingDict[tableCategories[3]] = [nEstimateStart, nEstimateWidth, "n_estimate", thousandFormatter];
    tableSpacingDict[tableCategories[4]] = [nMoeStart, nMoeWidth, "n_estimate_moe", customFormatter];
    tableSpacingDict[tableCategories[5]] = [populationStart, populationWidth, "base_population", thousandFormatter];
    tableSpacingDict[tableCategories[6]] = [sampleStart, sampleWidth, "sample_size", thousandFormatter];

    const tableGroupPositions = {}

    tableGroupPositions[tableGroups[0]] = [locationStart, locationWidth];
    tableGroupPositions[tableGroups[1]] = [d3.min([pEstimateStart, pMoeStart]), pEstimateWidth + pMoeWidth];
    tableGroupPositions[tableGroups[2]] = [d3.min([nEstimateStart, nMoeStart]), nEstimateWidth + nMoeWidth];
    tableGroupPositions[tableGroups[3]] = [populationStart, populationWidth];
    tableGroupPositions[tableGroups[4]] = [sampleStart, sampleWidth];

    // console.log(tableSpacingDict["Location"][3] != null);

    const percentScale = d3.scaleLinear()
      //.domain(empExtent)
      .domain([0, 100]) // for 0-100% scale vs. empExtent
      .range([0, empChartWidth - (sampleStart + sampleWidth)]);




    // temp
    let drawWith = true;
    let drawWithout = true;
    let drawGap = true;
    // const loadEmpData = async function () {

    //   // ======        
    //   //  DATA
    //   // ======
    //   let empData = await d3.csv("acs_emp03.csv", d3.autoType)
    //   let goodData = unstackDataset(empData);
    //   console.log(goodData);

    //   let allWithout = d3.map(goodData, d => {
    //     return d["without"];
    //   })



    //   updateTableRows(goodData);
    // }

    function unstackDataset(stackedCSV) {
      // takes in the 104 stacked rows from the CSV 
      // returns 52 unstacked rows that have both "with" and "without" keys 
      //  for the matching p_estimates
      // RUN THIS FIRST TO MAKE A GOOD DATASET, THEN SORT AND EVERYTHING ELSE!

      let new_dataset = {};

      stackedCSV.forEach(d => {
        // check which kind of data it is
        let label = ""
        if (d.disability_type === 1) {
          label = "with";
        }
        else if (d.v2 === 2) {
          label = "without";
        }
        else {
          label = "NULL";
        }

        let location = d.location;
        if (location in new_dataset) {
          // update the row with the new value
          new_dataset[location][label] = d.p_estimate;
        }
        else
          new_dataset[location] = {
            "location": d.location,
            "sample_size": d.sample_size,
            "base_population": d.base_population,
            "n_estimate": d.n_estimate,
            "n_estimate_moe": d.n_estimate_moe,
            "p_estimate": d.p_estimate,
            "p_estimate_moe": d.p_estimate_moe,
            "id": d.id
          }
        new_dataset[location][label] = d.p_estimate;

      });

      // we need to convert from a dictionary back into a simple array
      return Object.values(new_dataset);

    }



    function updateTableRows(sorted_dataset) {
      // console.log(sorted_dataset);
      // sorted_dataset.forEach(d => {
      //   console.log("This loop: ", d["location"]);
      // });    
      addHeader(empSVG);

      empSVG.selectAll('g.row').remove();

      empSVG.selectAll('g.row')
        .data(sorted_dataset, d => d["state"])
        .join(enter => {
          let rows = enter.append("g").attr("class", "row");
          rows.attr("transform", (d, i) => `translate(0, ${empSVGMargin.top + headerHeight + i * rowHeight})`);

          // TODO add and configure the text part including their x position
          //   y position should always take into account the translate above
          rows.append("line")
            .attr("class", "tableSeperator")
            .attr("x1", 0)
            .attr("x2", empChartWidth + 45)
            .attr("y1", 0)
            .attr("y2", 0)

          tableCategories.forEach(cat => {

            rows.append("text")
              .attr("class", `tableText ${cat}`)
              .text(d => {
                if (tableSpacingDict[cat][3] != null) {
                  return tableSpacingDict[cat][3](d[tableSpacingDict[cat][2]]);
                }
                return d[tableSpacingDict[cat][2]]
              })
              .attr("x", d => {
                if (cat == tableCategories[0]) {
                  return tableSpacingDict[cat][0] + textMargin;
                }
                return tableSpacingDict[cat][0] + tableSpacingDict[cat][1] - textMargin;
              })
              .attr("y", rowHeight / 2);
          });


          // add the fancy sub-chart
          let subcharts = rows.append("g")
            .attr("class", "empSVG")
            .attr("transform", `translate(${sampleStart + sampleWidth}, 0)`)
          // shift the chart over a bit so its on right side

          // but how do we get each of the charts to have the right contents?
          //  ... and, how do we make sure they update properly

          subcharts.each(updateEmpSvg)

        },
          update => {
            update.transition() // animate them shuffling around???
              .attr("transform", (d, i) => `translate(0, ${i * rowHeight})`);

            // select and update each of the text elements as necessary
            //  (this is why it's important to add classes in enter)
            update.select("text.p_est")
              .text(d => d['p_est']);
            // ... append other text inside of the rows

            // select and update the fancy sub-chart
            //  (this is why it's important to add classes in enter)
            let subcharts = update.selectAll("g.empSVG")

            // but how do we get each of the charts to have the right contents?
            //  ... and, how do we make sure they update properly
            subcharts.each(updateEmpSvg)

          },
          exit => {
            exit.transition()
              .attr("opacity", 0)
              .remove()
          });
    }

    function updateEmpSvg(d, i) {
      // expects to get one point of data from your array
      // e.g. d={'with_est':,'without_est':}

      // console.log("updateEmpSvg", i, d);

      let empSVG = d3.select(this);

      if (drawWithout && !plottingPrevalenceTable) {
        let lightBlueLine = empSVG.selectAll("rect.withoutBar")
          .data([d])
          .join( // make new bar without animation
            enter => enter.append("rect")
              .attr("class", "withoutBar")
              .attr("x", 0)
              .attr("y", barMargin)
              .attr("width", d => percentScale(d.without))
              .attr("height", rowHeight - 2 * barMargin)
              .on("mouseover", d => { })
            ,
            // update bar with moving line animations
            // for animation, add .call
            update => update.call(update =>
              update.transition()
                .attr("width", d => percentScale(d.without))
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            });
      }

      if (drawWith) {
        let darkBlueLine = empSVG.selectAll("rect.withBar")
          .data([d])
          .join( // make new bar without animation
            enter => enter.append("rect")
              .attr("class", "withBar")
              .attr("x", 0)
              .attr("y", barMargin)
              .attr("width", d => {
                if (plottingPrevalenceTable) {
                  return percentScale(d.p_estimate);
                }
                return percentScale(d.with);
              })
              .attr("height", rowHeight - 2 * barMargin)
              .on("mouseover", d => { })
            ,
            // update bar with moving line animations
            // for animation, add .call
            update => update.call(update =>
              update.transition()
                .attr("width", d => {
                  if (plottingPrevalenceTable) {
                    return percentScale(d.p_estimate);
                  }
                  return percentScale(d.with);
                })
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            });
        let darkBlueCircle = empSVG.selectAll("circle.withEndCircle")
          .data([d])
          .join(
            enter => enter.append("circle")
              .attr("class", "withEndCircle")
              .attr("cx", d => {
                if (plottingPrevalenceTable) {
                  return percentScale(d.p_estimate);
                }
                return percentScale(d.with);
              })
              .attr("cy", rowHeight / 2)
              .attr("r", endCircleRadius)
              .attr("rowIndex", i)
              .on("mouseover", circleHover)
              .on("mouseleave", circleUnhover)
            ,

            update => update.call(update =>
              update.transition()
                .attr("cx", d => {
                  if (plottingPrevalenceTable) {
                    return percentScale(d.p_estimate);
                  }
                  return percentScale(d.with);
                })
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            })
      }


      if (drawWithout && !plottingPrevalenceTable) {
        let lightBlueCircle = empSVG.selectAll("circle.withoutEndCircle")
          .data([d])
          .join(
            enter => enter.append("circle")
              .attr("class", "withoutEndCircle")
              .attr("cx", d => percentScale(d.without))
              .attr("cy", rowHeight / 2)
              .attr("r", endCircleRadius)
              .attr("rowIndex", i)
              .on("mouseover", circleHover)
              .on("mouseleave", circleUnhover)
            ,

            update => update.call(update =>
              update.transition()
                .attr("cx", d => percentScale(d.without))
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            })

      }
      if (drawGap && !plottingPrevalenceTable) {

        let gapText = empSVG.selectAll("text.gapText")
          .data([d])
          .join(
            enter => enter.append("text")
              .attr("class", "tableText gapText")
              .attr("x", empChartWidth - (sampleStart + sampleWidth))
              .attr("y", rowHeight / 2)
              .text(d => floatFormatter(d.without - d.with) + "%")
          );
      }

    }

    function circleHover(event, d) {
      // console.log(event, d);
      let circle = d3.select(this)
        .attr("r", endCircleRadius * 1)
        .style("fill", "white")
        .attr("stroke", "black")
        .attr("stroke-width", "8px");

      let xPos = Number(circle.attr("cx")) + sampleStart + sampleWidth;
      let yPos = Number(circle.attr("cy")) + headerHeight + rowHeight * circle.attr("rowIndex");

      let g = empSVG.append("g")
        .attr("transform", `translate(${xPos - mouseOverLabelBoxWidth / 2}, ${yPos})`)
        .attr("class", "mouseOverLabel")
        .style("pointer-events", "none")
      g.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", mouseOverLabelBoxWidth)
        .attr("height", mouseOverLabelBoxHeight)
        .attr("fill", "white")
        .attr("stroke", "black")
      g.append("text")
        .attr("x", mouseOverLabelBoxWidth / 2)
        .attr("y", mouseOverLabelBoxHeight / 2)
        .attr("font-size", tableFontSize + "px")
        .attr("dominant-baseline", "middle")
        .attr("text-anchor", "middle")
        .text("Rate: " + d.p_estimate + "%")
    }

    function circleUnhover(event, d) {
      d3.select(this)
        .attr("r", endCircleRadius)
        .style("fill", "")
        .attr("stroke", "none")
        .attr("stroke-width", "0px");

      empSVG.select(".mouseOverLabel").remove() // find the thing with the class and remove it
    }

    function addHeader(target) {
      var headerGroup = target.append("g")
        .attr("class", "tHeader")
        .attr("transform", `translate(${0}, ${empSVGMargin.top})`);

      tableGroups.forEach(group => {
        headerGroup.append("rect")
          .attr("class", `tableHeaderBox ${group}`)
          .attr("x", tableGroupPositions[group][0])
          .attr("width", tableGroupPositions[group][1])
          .attr("height", headerHeight);

        if (group != tableGroups[0]) {
          let closeProtrusion = headerGroup.append("rect")
            .attr("class", `tableHeaderBox closeProtrusion ${group}`)
            .attr("x", tableGroupPositions[group][0] + tableGroupPositions[group][1] - closeWidth)
            .attr("y", -closeHeight)
            .attr("width", closeWidth)
            .attr("height", closeHeight);

          let closeSquare = headerGroup.append("rect")
            .attr("class", `closeSquare`)
            .attr("x", Number(closeProtrusion.attr("x")) + (closeWidth) / 4)
            .attr("y", -closeInnerBoxHeight)
            .attr("width", closeWidth / 2)
            .attr("height", closeInnerBoxHeight)
            .on("click", closeGroup);

          headerGroup.append("line")
            .attr("class", `closeX`)
            .attr("x1", Number(closeSquare.attr("x")) + xMargin)
            .attr("x2", Number(closeSquare.attr("x")) + (closeWidth / 2) - xMargin)
            .attr("y1", -closeInnerBoxHeight + xMargin)
            .attr("y2", - xMargin)
            .attr("stroke", "black");

          headerGroup.append("line")
            .attr("class", `closeX`)
            .attr("x2", Number(closeSquare.attr("x")) + xMargin)
            .attr("x1", Number(closeSquare.attr("x")) + (closeWidth / 2) - xMargin)
            .attr("y1", -closeInnerBoxHeight + xMargin)
            .attr("y2", -xMargin)
            .attr("stroke", "black");
        }

      });

      tableCategories.forEach(cat => {
        const headerText = headerGroup.append("text")
          .attr("class", `tHeaderText tableText ${cat}`)
          .attr("x", tableSpacingDict[cat][0] + (textMargin))
          .attr("y", (rowHeight / 2) - (1.5 * tableFontSize));


        const words = cat.split(" ");
        if (words.length > 1) {
          words.forEach((word, index) => {
            headerText.append("tspan")
              .attr("x", tableSpacingDict[cat][0] + (tableSpacingDict[cat][1]) - textMargin)
              .text(word)
              .attr("dy", 1.5 * tableFontSize)
          });
        } else {
          headerText.text(cat).attr("y", (rowHeight / 2) + 18);
        }



      });


      function closeGroup(event, d) {
        //TODO CORBIN
        console.log("hi");
      }



      return headerGroup;
    }
    // loadEmpData();



  </script>

</body>