<html>

<head>
  <title>INFO 4310 - HW4</title>
  <!-- <link href="./style.css" rel="stylesheet" type="text/css"> -->

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">


  <style>
    body {
      font-family: 'Barlow', 'Helvetica', sans-serif;
      font-weight: 400;
      margin: 0 0 0 100px;
      padding: 0;
      min-width: 1400px;
      overflow-x: scroll;
      overflow-y: hidden;
      overscroll-behavior-x: none;
    }

    h1 {
      font-weight: 800;
      font-size: 3em;
      margin: 20px 0 0 0;
      padding: 0;
      background: linear-gradient(to right, #7339D0, #d81289);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    h2 {
      font-weight: 700;
      font-size: 1em;
      margin: 0;
      padding: 0 0 5px 0;
      color: #777;
      border-bottom: 1px solid #777;
    }

    h3 {
      font-weight: 700;
      font-size: 1.05em;
      margin: 0;
      padding: 20px 0 15px 0;
      color: #7339D0;
    }

    h3.withRule {
      border-top: 1px solid #ccc;
      padding-top: 12px;
      margin-top: 15px;
    }

    h3#best {
      font-weight: 800;
      font-size: 1.15em;
      color: #d81289;
    }

    p {
      margin: 0;
      padding: 3px 0;
      line-height: 1.3em;
    }

    p#tagline {
      font-size: 1.1em;
      color: #7339D0;
      margin: 0;
      padding: 0 0 35 0;
    }

    /* BUTTONS */
    button {
      font-family: 'Barlow', 'Helvetica', sans-serif;
      background-color: #ffffff;
      border: 2px solid #777;
      color: #777;
      border-radius: 20px;
      margin: 0 7px 10px 0;
      padding: 6px 10px 8px 10px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
    }

    /* button[value="cafes"]::before {
      content: "#";
      color: gray;
    }
    .clicked[value="cafes"]::before {
      content: url("logo.png");
      content: "#";
      color: purple;
    }     */

    .clicked {
      background-color: #e3d2fd;
      border: 2px solid #7339D0;
      color: #7339D0;
    }

    button:hover {
      text-decoration: underline dotted;
      text-underline-offset: 3px;
    }

    .clicked:hover {
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    #distance button {
      width: 80px;
    }

    #category button {
      width: 125px;
    }

    button#selectAllButton,
    button#resetButton {
      margin: 0 0 12px 0;
      padding: 0;
      border: 0;
      font-size: .95em;
      font-weight: 500;
      color: #7339D0;
    }

    #selectAllButton:hover,
    #resetButton:hover {
      background-color: white;
      border: 0;
      border-radius: 0;
      text-decoration: underline dotted;
      text-underline-offset: 3px;
    }

    /* CONTAINERS */
    .flex-container {
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      flex-wrap: nowrap;
    }

    div.filterColumn {
      margin: 0;
      padding: 10px 35px 10px 0;
      min-width: 300px;
      max-width: 300px;
    }

    div.filterButtonContainer {
      height: calc(100vh - 170px);
      overflow-y: scroll;
    }

    div.restaurant-list-info {
      max-width: 400px;
      min-width: 300px;
      margin: 0;
      padding: 145px 20px 0 0;
    }

    .restaurant-list {
      height: calc(100vh - 240px);
      margin: 0;
      padding: 5px 35px 10px 10px;
      overflow-y: scroll;
    }

    .restaurant-list a {
      text-decoration: none !important;
      color: inherit;
    }

    .restaurant-item {
      margin-bottom: 10px;
    }

    .restaurant-card {
      border: 1px solid #ccc;
      border-radius: 20px;
      padding: 20px 30px;
      margin: 0 0 13px 0;
      font-size: medium;
      box-shadow: 0 0 7px #ccc;
    }

    .restaurant-card div.categoryDivStyle,
    .restaurant-card-hover div.categoryDivStyle,
    .best-restaurant-card-hover div.categoryDivStyle {
      margin: 6px 0 8px 0;
    }

    .restaurant-card-hover span.categoryStyle {
      margin: 2px 5px 2px 0;
      padding: 2px 6px 4px 6px;
      border: 1px solid #7339D0;
      color: #7339D0;
      font-weight: 600;
      font-size: .95em;
      text-transform: lowercase;
      border-radius: 11px;
    }

    .restaurant-card span.categoryStyle,
    .best-restaurant-card-hover span.categoryStyle {
      margin: 2px 5px 2px 0;
      padding: 2px 6px 4px 6px;
      border: 1px solid #C63186;
      color: #C63186;
      font-weight: 600;
      font-size: .95em;
      text-transform: lowercase;
      border-radius: 11px;
    }

    .restaurant-card p.snippetStyle,
    .restaurant-card-hover p.snippetStyle,
    .best-restaurant-card-hover p.snippetStyle {
      margin: 5px 0 0 30px;
      text-indent: 0;
      font-style: italic;
    }

    .restaurant-card p.snippetStyle::before,
    .restaurant-card-hover p.snippetStyle::before,
    .best-restaurant-card-hover p.snippetStyle::before {
      content: url('snippet.svg');
      width: 24px;
      margin: 0 0 0 -28px;
      padding: 0;
      display: inline-block;
      /* border: 1px solid red; */
    }

    .restaurant-card-hover,
    .best-restaurant-card-hover {
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 5px 5px;
      margin: 0 0 10px 0;
      font-size: small;
      box-shadow: 0 0 7px #ccc;
      background-color: rgba(255, 255, 255, 0.9);
    }

    div.mapColumn {
      overflow-x: scroll;
      overflow-y: hidden;
    }

    .tick line {
      visibility: hidden;
    }

    .tick text {
      font-size: 16px
    }

    .domain {
      visibility: hidden;

    }
  </style>

</head>

<body>

  <div class="flex-container">

    <!--  ---------------
              FILTERS 
          --------------- -->
    <div class="filterColumn">
      <h2>FILTERS</h2>

      <div class="filterButtonContainer">

        <!-- RATING FILTER-->
        <h3>RATING</h3>
        <svg id="histogram" width="300" height="115"></svg>

        <!-- DISTANCE FILTER-->
        <h3 class="withRule">DISTANCE</h3>
        <div id="distance">
          <button id="mi1_4">.25 mi</button>
          <button id="mi1_2">.5 mi</button>
          <button id="mi1">1 mi</button>
        </div>

        <!-- CATEGORY FILTER-->
        <h3 class="withRule">CATEGORY</h3>
        <button id="selectAllButton" value="selectAll">SELECT ALL</button>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<button
          id="resetButton" value="reset">CLEAR ALL</button>

        <div id="category">
          <button id="c01" value="restaurants">restaurants</button>
          <button id="c02" value="cafes">cafes</button>
          <button id="c03" value="coffee">coffee</button>
          <button id="c04" value="sandwiches">sandwiches</button>
          <button id="c05" value="sushi">sushi</button>
          <button id="c06" value="pizza">pizza</button>
          <button id="c07" value="donuts">donuts</button>
          <button id="c08" value="bakeries">bakeries</button>
          <button id="c09" value="ethnicmarkets">ethnic</button>
          <button id="c10" value="newamerican">american</button>
          <button id="c11" value="chinese">chinese</button>
          <button id="c12" value="french">french</button>
          <button id="c13" value="indpak">indpak</button>
          <button id="c14" value="italian">italian</button>
          <button id="c15" value="japanese">japanese</button>
          <button id="c16" value="mexican">mexican</button>
          <button id="c17" value="thai">thai</button>
          <button id="c18" value="vietnamese">vietnamese</button>
        </div>

      </div>
    </div>


    <!--  ---------------
                MAP 
          --------------- -->
    <div class="mapColumn">
      <div id="restaurant-hover" class="restaurant-hover" style="position:absolute"></div>
      <svg id="svgMap" width="1000" height="1100" top="30">
      </svg>
    </div>

  </div>



  <!-- ==================
        MAP SCRIPT
    =================== -->
  <script id="map">
    const svgMap = d3.select("#svgMap");
    const width = svgMap.attr("width");
    const height = svgMap.attr("height");
    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/ckttxzrvq0s4i18l4he5vtltt/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`

    //set up colors 
    const selectedColor = "#7339D0";
    const greyedoutColor = "#A5A0AC";

    const requestMapData = async () => {

      //state data
      // let statesAll = await d3.csv("./acs_prevalence.csv", d3.autoType);
      // let states = statesAll; //this is used for filtering

      //filters that's placed on statesAll for current View
      var filters = {};

      // MAP
      const projection = d3.geoMercator() //geoAlbersUsa() to see alaska
        .scale(1 / (2 * Math.PI))
        .translate([0, 0]);


      const render = d3.geoPath(projection);


      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = svgMap.append("g")
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      const us = await d3.json("./us.json");
      const code_names = await d3.csv("./state-name-codes.csv", d3.autoType);


      // 3b. Generate the data structures we will need
      var stateDict = {}   // stateID ===> stateData

      code_names.forEach(d => {
        stateDict[d.state_code] = d.state_name;
      });

      // us.objects.state.forEach(d => {
      //   d.name = stateDict[d.id]
      // });



      console.log(us);
      var states = topojson.feature(us, us.objects.states);     // List of state outlines to fill
      var statesMesh = topojson.mesh(us, us.objects.states);    // 'Mesh' of all outlines put together for a stroke


      states.features.forEach(d => { d.name = stateDict[d.id] });
      console.log("do states have names?", states);


      var data = []; //TODO: update this when data changes, colorScale will also be automatically updated
      let colors = d3.schemeBlues[9];
      //let colorScaleState = d3.scaleQuantize(d3.extent(statePercentages), colors);

      //Mouseover interaction
      let tooltipWidth = 250;
      let tooltipHeight = 45;

      let tooltip = svgMap.append("g")
        .attr("class", "tooltip")
        .attr("transform", `translate(${20},20)`)
        .attr("visibility", "hidden");

      let box = tooltip.append("rect")
        .attr("fill", "white")
        .attr("opacity", 0.8)
        .attr("x", 0)
        .attr("y", 0)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 5);
      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 25);

      let statePaths = svgMap.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)  // debugging
        .attr("d", render)
        .attr("fill", "red")
        .attr("opacity", 0.5)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState);

      let momesh = svgMap.append("path")
        .attr("class", "mouseover outline")
        .style("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .attr("d", "");

      function mouseEntersState() {
        // Make tooltip visible
        tooltip.style("visibility", "visible")

        // Find the state SVG element and add stroke
        let state = d3.select(this);

        // Using .datum() to recover the data for the state element (because we used a .join() to make it)...
        // ... get the name of the state and count
        let stateID = state.datum().id;
        // let stateDat = stateDict[stateID]

        txt.text(state.datum().name);
        // txt2.text(stateDat.total);

        // You can use the geoPath() generator to do all sorts of helpful things 
        // let [xPos, yPos] = path.centroid( state.datum() );  // Get the pixel "center" of the state

        let bounds = render.bounds(state.datum());   // Get the pixel boundaries of the state
        // In both cases here, the geoPath() is parsing the fancy topoJSON data to figure out pixels using the projection

        // Place it at the bottom of the state, centered
        let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        let yPos = bounds[1][1] - 15;

        // Transform the <g> group so that everything moves together easily
        tooltip.attr("transform", `translate(${xPos},${yPos})`);

        // To fix the oscillation, we add this in the CSS for .mouseover
        //  pointer-events: none;

        // ** Adding this code can do the mouseover outline the "proper" way
        // Technically, the right way to do this is with another mesh for some complicated reasons
        //  You have to use the second parameter of topojson.mesh() to pick out this state's boundaries
        // First, make a new mesh with a filter for only borders of the current state
        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });

        //  Then apply it to your special mesh that's on top of everything else (added earlier in this file)
        momesh.datum(mo).attr("d", render)




      }

      function mouseLeavesState() {

        // Hide when you leave a state
        tooltip.style("visibility", "hidden");

        let state = d3.select(this);

        // Reset old style mouseover stroke
        // state.attr("stroke","none")
        //      .attr("stroke-width", 0);
        // }

        // Here we are hiding the mouseover mesh we added as bonus content
        //momesh.attr("d", "");

      }
      var zoom = d3.zoom()
        .scaleExtent([1 << 12, 1 << 20])
        .on("zoom", ({ transform }) => zoomed(transform));


      //centerLocation
      let centerCoordinates = {
        latitude: 41.4925,
        longitude: -99.9018
      };

      svgMap
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(- 1 << 12)
          .translate(...projection([centerCoordinates.longitude, centerCoordinates.latitude]))
          .scale(-1)
        )
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {
        // console.log("regular projection", projection([42.36541856, -71.05688332]))

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);


          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);

        });

        projection
          .scale(transform.k / (2 * Math.PI))
          .translate([transform.x, transform.y]);

        statePaths.attr("d", d3.geoPath(projection))

      };


      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      //calls update on filters
      function updateData() {

        //update filters


        // Draw the circles
        // svgEateries.selectAll("circle.eateries").data(eateries)
        //   .join("circle")
        //   .attr("class", "eateries")
        //   .attr("fill", (d) => {
        //     d.dist = getDistanceFromLatLonInMiles(myCoordinates.latitude, myCoordinates.longitude, d.latitude, d.longitude);
        //     d.inside = d.dist < filter_dist
        //     if (d.inside) {
        //       return selectedColor
        //     }
        //     else { return greyedoutColor }
        //   })
        //   .attr("r", 5)
        //   .style("stroke", "white")
        //   .attr("stroke-width", (d) => {
        //     if (d.inside) { return "2px" }
        //   })
        //   .attr("opacity", 0.9)
        //   .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`)
        //   .on("mouseover", (e, d) => {
        //     // console.log("normal")
        //     updateRestaurantHover([d], e.offsetX, e.offsetY, false)

        //   })
        //   .on("mouseout", (event) => {
        //     d3
        //       .select('#restaurant-hover')
        //       .selectAll("*").remove();
        //   });


      }

      updateData();

    }

    requestMapData();

    // ---------------
    // HELPER FUNCTIONS
    // ---------------

    //makes sure element shows up within bounds
    function elementLocation(mouseX, mouseY, elementWidth, elementHeight, boundaryX, xMargin, yMargin) {

      let xPos = mouseX + xMargin;
      let yPos = mouseY - yMargin - elementHeight;

      if ((xPos + elementWidth) > boundaryX) {
        xPos = mouseX - xMargin - elementWidth
      }
      if (yPos < 0) {
        yPos = mouseY - yMargin
      }

      return { x: xPos, y: yPos };

    }



  </script>

</body>