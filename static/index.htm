<html>

<head>
  <title>INFO 4310 - HW4</title>
  <link href="./style.css" rel="stylesheet" type="text/css">
  <!-- <link href="./style.css" rel="stylesheet" type="text/css"> -->

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <style>
    body {
      font-family: 'Barlow', 'Helvetica', sans-serif;
      font-weight: 400;
      margin: 0;
      padding: 0;
      /* min-width: 1300px;
      max-width: 1400px;
      overflow-x: scroll;
      overflow-y: hidden;
      overscroll-behavior-x: none; */
    }
    title {
      display: block;
      font-weight: 400;
      font-size: 1.65em;
      padding: 0;
      margin: 0;
      color: #1059C9;
    }
    h1 {
      font-weight: 700;
      font-size: 2.75em;
      margin: 0;
      padding: 0;
      color: #1059C9;
    }
    h2 {
      font-weight: 700;
      font-size: 1em;
      margin: 0;
      padding: 20px 0 0 0;
      color: black;
    }    
    h3 {
      font-size: 1em;
      font-weight: 700;
      padding: 0 0 10px 0;
      margin: 0 0 20px 0;
      color: #1059C9;
      border-bottom: 1px solid #1059C9;
      border-bottom-style: dotted;
    }   
    h4 {
      font-weight: 600;
      font-size: 1.5em;
      padding: 0 0 25px 0;
      margin: 0;
      color: black;
    }
    a {
      color: #1059C9;
      text-decoration: underline;
      text-decoration-style: dashed;
      text-underline-offset: 4px;
    }
    a:hover {
      color: #1059C9;
      text-decoration: underline;
      text-decoration-style: solid;
      text-underline-offset: 4px;
    }
    p {
      margin: 0;
      padding: 3px 0;
      line-height: 1.3em;
    }
    .quickFacts {
      width: 1000px;
      font-weight: 500;
      font-size: 2.4em;
      /* margin: 0; */
      margin: 0 0 20px 0;
      padding: 0;
      color: black;
    } 
    ul.quickFacts {
      margin: 0 0 15px 60px;
      line-height: 1.3em;
    }
    .withColor {
      color: #E1195F;
      font-weight: 800;
    }
    .withoutColor {
      color: #1059C9;
      font-weight: 800;
    }   
    .gapColor {
      color: #F96706;
      font-weight: 800;
    }
    .gapHighlight, .withHighlight, .withoutHighlight {
      text-decoration: underline;
      text-underline-offset: 5px;
    }  
    .withHighlight { text-decoration-color: #E1195F; }  
    .withoutHighlight { text-decoration-color: #1059C9; }  
    .gapHighlight { text-decoration-color: #F96706; }  
    p.mapTitle {
      font-weight: 500;
      font-size: 1.3em;
      margin: 0 0 1.3em 0;
    }   
    button#toggle {
      display:block;border: 0;background-color:#5396E8;color:white;width:70px;padding: 7px 0;
    } 
    button#toggleSearch {
      display:block;border: 0;background-color:#5396E8;color:white;width:70px;padding: 7px 0;
    } 

    /* =======
         GRID 
       ======= */
    /* MAIN CONTAINER */
    #container {  
    display: grid;
    min-width: 100vw;
    height: 100vh;
    grid-template-columns: 70px 320px 1fr;
    grid-template-rows: auto auto 245px auto .5fr 1fr 1fr;
    gap: 0 50px;
    grid-auto-flow: row;
    grid-template-areas:
      "masthead masthead masthead"
      "pageTitle pageTitle pageTitle"
      "dir1 quickStat quickStat"
      "dir2 filters map"
      "dir2 filters brush"
      "dir3 tableBar tableBar"
      ". footer footer"; 
      transition: 1s;   
    }

    /* child of #container: MASTHEAD CONTAINER */
    .masthead {
      display: grid; 
      grid-template-columns: 75px 300px 1fr; 
      grid-template-rows: 100px; 
      gap: 0px 20px; 
      height: 100px;
      grid-template-areas: "logo siteName indStat"; 
      grid-area: masthead; 
      align-items: center;
      position: sticky; /* keeps masthead stuck to top of screen */
      z-index: 1000;
      top: 0; 
      padding: 0 0 0 120px;
      background-color: white;  
      }
        /* children of masthead */
        .logo { grid-area: logo; padding: 0; text-align: left;}
        .siteName { grid-area: siteName; }
        .indStat { grid-area: indStat; } 

    /* LEFT COLUMN (possibly for directions) */
    .dir0 { grid-area: dir0; background-color: white; } 
    .dir1 { grid-area: dir1; background-color: #1059C9; }
    .dir2 { grid-area: dir2; }
    .dir3 { grid-area: dir3; }  

    /* full row for PAGE TITLE */
    .pageTitle { 
      grid-area: pageTitle; 
      position: sticky; 
      z-index: 999;
      top: 100px; 
      background-color: white;
      height: 100px;
      padding: 10px 0 0 120px;  
    }
    .quickStat { 
      grid-area: quickStat; 
      /* padding: 20px 0 40px 0;  */
      background-color: white;
      min-height: 0;
      margin: 0 150px 0 0;
      overflow: hidden;      
    }
    /* setting for collapsed state of quick stats triggered by "CLOSE STATS" button" */
    #container.collapsedQuickStats {
      grid-template-rows: auto auto 0 auto .5fr 1fr 1fr;
      padding: 0;
      margin: 0;
    }  
    .filters { 
      grid-area: filters; 
      margin: 105px 50px 0 0; 
      min-width: 0;
      overflow: hidden;       
    }
    /* setting for collapsed state of search filters triggered by "CLOSE SEARCH" button" */
    #container.collapsedFilters {
      grid-template-columns: 70px 0 1fr;
      padding: 0;
      margin: 0;
    }
    .map { 
      grid-area: map; 
      margin: 40px 150px 0 -50px; 
      min-width: 1200px;
      min-height: 1000px;
      overflow: hidden;
    }
    .brush { grid-area: brush; }
    .tableBar { grid-area: tableBar; }
    .footer { grid-area: footer; min-height: 300px;}

    /* CUSTOM SELECT FORMATTING */
    *, *::before, *::after {
    box-sizing: border-box;
    }
    select {
      appearance: none;
      background-color: transparent;
      border: none;
      padding: 0 1em 0 0;
      margin: 0;
      width: 100%;
      font-family: inherit;
      font-size: inherit;
      cursor: inherit;
      line-height: inherit;
      z-index: 1;
      outline: none;
    }
    select::-ms-expand {
      display: none;
    }
    /* Filter selects */
    .select {
      display: grid;
      grid-template-areas: "select";
      align-items: center;
      position: relative;
      border: 1px solid #1059C9;
      border-radius: 1em;
      padding: .5em .75em;
      margin: 0;
      font-size: rem;
      /* text-shadow: 2px 2px; */
      cursor: pointer;
      line-height: 1.3;
      color: black;
      background-image: linear-gradient(to top, #ddd, #fff 50%);
    }
    /* GRID for the INDIVIDUAL STATISTIC in masthead */
    .indStatGrid {
      display: grid; 
      grid-template-columns: 70px auto; 
      grid-template-rows: auto; 
      gap: 0 20px; 
      grid-template-areas: "indStatLabel indStatSelect"; 
      grid-area: indStatGrid; 
      align-items: center;
    }
    .indStatLabel { grid-area: indStatLabel; padding: 2px 0 0 0; }
    .indStatSelect { grid-area: indStatSelect; padding: 2px 0 0 0; }

    /* INDIVIDUAL STATISTIC select */
    .selectIndStat {
      display: grid;
      grid-template-areas: "select";
      align-items: center;
      position: relative;
      border: 1px solid #E1195F;
      border-radius: 1em;
      padding: .5em .75em .5em .75em;
      margin: 0;
      font-size: 1rem;
      cursor: pointer;
      line-height: 1.3;
      color: black;
      background-image: linear-gradient(to top, #ddd, #fff 50%);
      width: 300px;
    }
    .select select, .select::after, .selectIndStat select, .selectIndStat::after {
      grid-area: select;
    }
    /* style triangle */
    .select::after, .selectIndStat::after {
      content: "";
      justify-self: end;
      width: 0.8em;
      height: 0.5em;
      background-color: #5396E8;
      clip-path: polygon(100% 0%, 0 0%, 50% 100%);
    }
    .selectIndStat::after {
      content: "";
      justify-self: end;
      width: 0.8em;
      height: 0.5em;
      background-color: #E1195F;
      clip-path: polygon(100% 0%, 0 0%, 50% 100%);
    }
    .select:hover, .selectIndStat:hover {
      border: 1px solid #E1195F;
    }
    .select:hover::after, .selectIndStat:hover::after {
      background-color: #E1195F;
      clip-path: polygon(100% 0%, 0 0%, 50% 100%);
      transform: rotate(-.5turn);
      transition-duration: .5s;
    }    
    select:focus + .focus {
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      bottom: -1px;
      border: 2px solid #E1195F;
      border-radius: inherit;
    } 
    label {
      display: block;
      font-size: 1em;
      font-weight: 700;      
      margin: 5px .75em;
    }
    .indStatLabel label {
      font-weight: 500;
      margin: 0;
      padding: 0;
    }
    .select + label {
      margin-top: 1rem;
    }
 

    #content {
      display: grid;
      grid-template-rows: 0fr;
      transition: 1s;
      overflow: hidden;
    }
    #content .inside {
      min-height: 0;
    }
    #content.expanded {
      background: red;
      grid-template-rows: 1fr;
    }

  </style>
</head>


<body>

  <div id="container">
    <div class="dir0"></div>
    <div class="masthead">
      <div class="logo"><img src="logo.svg" height="75px"></div>
      <div class="siteName"><title>Disability Statistics</title></div>
      <div class="indStat">

        <!-- Grid containing label and menu to pick individual statistic -->
        <div class="indStatGrid">
          <div class="indStatLabel"><label for="indStat">STATISTIC:</label></div>
          <div class="indStatSelect">
            <!-- Select Menu -->
            <div class="selectIndStat">
              <select id="indStat" name="indStat">
                <option value="0">PREVALENCE</option>
                <option value="1" selected>EMPLOYMENT RATE</option>
                <option value="2">POVERTY</option>
              </select>
              <span class="focus"></span>        
            </div>

          </div>
        </div>

      </div>
    </div>
    <div class="pageTitle">      
      <h1>EMPLOYMENT RATE</h1>
    </div>
    <div class="dir1"></div>
    <div class="quickStat">
        <h3>QUICK STATS</h3>
        <p class="quickFacts">
          In 2022, the national employment rate for people <span class="withHighlight">with</span> disabilities
          was <span class="withColor">45.0%</span> compared to <span class="withoutColor">81.0%</span> for people <span class="withoutHighlight">without</span> disabilities, an <span class="gapHighlight">employment gap</span> of <span class="gapColor">36.0%</span>.
        </p>
        2022 AMERICAN COMMUNITY SURVEY
        <!-- &nbsp;&nbsp;|&nbsp;&nbsp;<a href="">EMPLOYMENT RATE DEFINITION</a> -->
    </div>
    <div class="dir2">     
      <button id="toggle">CLOSE STATS</button>
      <br>
      <button id="toggleSearch">CLOSE SEARCH</button>

    </div>
    <div class="filters">
      <!--  ---------------
              FILTERS 
          --------------- -->
      <h3>SEARCH</h3>
      <!-- <button id="selectAllButton" value="selectAll">SELECT ALL</button>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<buttoncid="resetButton" value="reset">CLEAR ALL</button> -->

        <label for="region">REGION</label>
        <div class="select">
          <select id="region" name="region">
            <option value="0" selected>All Regions</option>
            <option value="1">Northeast</option>
            <option value="2">Midwest</option>
            <option value="3">South</option>
            <option value="4">West</option>
          </select>
          <span class="focus"></span>        
        </div>

        <label for="mapType">MAP TYPE</label>
        <div class="select">
          <select id="mapType" name="mapType">
            <option value="0" selected>With or Without Disability</option>
            <option value="1">With Disability</option>
            <option value="2">Without Disability</option>
          </select>
          <span class="focus"></span>        
        </div>            

        <label for="gender">GENDER</label>
        <div class="select">
          <select id="gender" name="gender">
            <option value="0" selected>Male or Female</option>
            <option value="1">Males</option>
            <option value="2">Females</option>
          </select>
          <span class="focus"></span>        
        </div>

        <label for="disabilityType">DISABILITY TYPE</label>
        <div class="select">
          <select id="disabilityType" name="disabilityType">
            <option value="1" selected>Any Disability</option>
            <option value="2">Visual Disability</option>
            <option value="3">Hearing Disability</option>
            <option value="4">Ambulatory Disability</option>
            <option value="5">Cognitive Disability</option>
            <option value="6">Self-Care Disability</option>
            <option value="7">Independent Living Disability</option>
          </select>
          <span class="focus"></span>        
        </div>            

        <label for="age">AGE</label>
        <div class="select">
          <select id="age" name="age">
            <option value="0" selected>All Ages</option>
            <option value="5">Ages 4 and under</option>
            <option value="6">Ages 5-15</option>
            <option value="1">Ages 16-20</option>
            <option value="2">Ages 21-64</option>
            <option value="3">Ages 16-64</option>
            <option value="4">Ages 18-64</option>
            <option value="7">Ages 65-74</option>
            <option value="9">Ages 65+</option>
            <option value="8">Ages 75+</option>
          </select>
          <span class="focus"></span>        
        </div>            

        <label for="race">RACE</label>
        <div class="select">
          <select id="race" name="race">
            <option value="0" selected>All races</option>
            <option value="1">White</option>
            <option value="2">Black/African American</option>
            <option value="3">Native American or Alaska Native</option>
            <option value="4">Asian</option>
            <option value="5">Some other race(s)</option>
          </select>
          <span class="focus"></span>        
        </div>            

        <label for="education">EDUCATION</label>
        <div class="select">
          <select id="education" name="education">
            <option value="0" selected>All education levels</option>
            <option value="1">Less than a high school education</option>
            <option value="2">A high school diploma or equivalent</option>
            <option value="3">Some college/associates degree</option>
            <option value="4">A BA degree or higher</option>
          </select>
          <span class="focus"></span>        
        </div>            

        <label for="hispanic">HISPANIC</label>
        <div class="select">
          <select id="hispanic" name="hispanic">
            <option value="0" selected>Regardless of ethnicity</option>
            <option value="1">Hispanic</option>
            <option value="2">Non-Hispanic</option>
          </select>
          <span class="focus"></span>        
        </div>

    </div>
    <div class="map">
    <!--  ---------------
                MAP 
          --------------- -->
      <h3>MAP</h3>
      <h4>EMPLOYMENT RATE: <br>The employment rate for non-institutionalized,
        <span id="gender">male or female</span>,
        with <span id="disabilityType">any</span> disability,
        <span id="age">all ages</span>,
        <span id="race">all races</span>,
        <span id="hispanic">regardless of ethnicity</span>,
        with <span id="education"></span> in the Unites States is <span id="dynamic_p_estimate">13.9%</span> in 2022.
      </h4>
      <!-- MAP -->
      <svg id="svgMap" width="1600" height="800" top="10"></svg>

    </div>
    <div class="brush"></div>
    <div class="dir3"></div>
    <div class="tableBar">

      
    </div>
    <div class="footer"></div>
  </div>

  <!--  =======================
        SHOW/HIDE FILTER SCRIPT
        ======================= -->
  <script id="toggleScript">
    // toggle view of quick stats
    toggle.onclick = () => {
    container.classList.toggle("collapsedQuickStats");
    // Check if the button text is "CLOSE STATS"
    if (toggle.textContent === "CLOSE STATS") {
        // If so, change it to "OPEN STATS"
        toggle.textContent = "OPEN STATS";
    } else {
        // Otherwise, change it back to "CLOSE"
        toggle.textContent = "CLOSE STATS";
    }
  };

  // toggle view of search filters
  toggleSearch.onclick = () => {
  container.classList.toggle("collapsedFilters");
  // Check if the button text is "CLOSE SEARCH"
  if (toggleSearch.textContent === "CLOSE SEARCH") {
      // If so, change it to "OPEN SEARCH"
      toggleSearch.textContent = "OPEN SEARCH";
  } else {
      // Otherwise, change it back to "CLOSE SEARCH"
      toggleSearch.textContent = "CLOSE SEARCH";
  }
  };
  </script>

  <!--  =======================
               MAP SCRIPT
        ======================= -->
        <script id="map">
    const svgMap = d3.select("#svgMap");
    const width = svgMap.attr("width");
    const height = svgMap.attr("height");
    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/ckttxzrvq0s4i18l4he5vtltt/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`

    //set up colors 
    const selectedColor = "#7339D0";
    const greyedoutColor = "#A5A0AC";

    //TODO actually switch this when we swap table type
    let plottingPrevalenceTable = true;


    const requestMapData = async () => {

      //initialize dict with column values
      let columnValues = {
        mapType: 0,
        gender: 0,
        disabilityType: 1,
        age: 0,
        race: 0,
        education: 0,
        hispanic: 0,
        region: 0
      };


      let regions = {
        0: [
          "the United States",
          "Alabama",
          "Alaska",
          "Arizona",
          "Arkansas",
          "California",
          "Colorado",
          "Connecticut",
          "Delaware",
          "Florida",
          "Georgia",
          "Hawaii",
          "Idaho",
          "Illinois",
          "Indiana",
          "Iowa",
          "Kansas",
          "Kentucky",
          "Louisiana",
          "Maine",
          "Maryland",
          "Massachusetts",
          "Michigan",
          "Minnesota",
          "Mississippi",
          "Missouri",
          "Montana",
          "Nebraska",
          "Nevada",
          "New Hampshire",
          "New Jersey",
          "New Mexico",
          "New York",
          "North Carolina",
          "North Dakota",
          "Ohio",
          "Oklahoma",
          "Oregon",
          "Pennsylvania",
          "Rhode Island",
          "South Carolina",
          "South Dakota",
          "Tennessee",
          "Texas",
          "Utah",
          "Vermont",
          "Virginia",
          "Washington",
          "West Virginia",
          "Wisconsin",
          "Wyoming",
          "Puerto Rico"
        ],
        1: ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
        2: ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
        3: ['Alabama', 'Arkansas', 'Delaware', 'District of Columbia', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia'],
        4: ['Alaska', 'Arizona', 'California', 'Colorado', 'Hawaii', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Oregon', 'Utah', 'Washington', 'Wyoming']
      }

      //state data (filter based on selected)
      let statesAll = await d3.csv("./acs_prevalence2.csv", d3.autoType);
      let statesData = statesAll.filter(function (row) {
        return (
          row.gender === columnValues.gender
          &&
          row.disability_type === columnValues.disabilityType
          &&
          row.age === columnValues.age &&
          row.race === columnValues.race &&
          row.education === columnValues.education &&
          row.hispanic === columnValues.hispanic
        )
      }); //this is used for filtering

      // console.log(statesData);
      //setting up selections to track selections for prevalence 
      //TODO: need to adapt to different datasets
      let prevalenceColumns = ["region", "mapType", "gender", "disabilityType", "age", "race", "education", "hispanic"];
      prevalenceColumns.forEach((d) => {

        d3.select(`select#${d}`)
          .on("change", function () {
            columnValues[d] = Number(d3.select(this).property("value"));
            //console.log(`${d} changed, logging column values:`, columnValues);

            updateData();
          });
      })


      //these are columns that affect text
      let textColumns = ["gender", "disabilityType", "age", "race", "education", "hispanic"]


      //load map data and match up state names to codes
      const us = await d3.json("./us.json");
      const code_names = await d3.csv("./state-name-codes.csv", d3.autoType);


      // 3b. Generate the data structures we will need
      var stateDict = {}   // stateID ===> stateData

      code_names.forEach(d => {
        stateDict[d.state_code] = d.state_name;
      });

      var dataDict = {}
      statesData.forEach(d => {
        dataDict[d.state] = { n_estimate: d.n_estimate, p_estimate: d.p_estimate }
      });
      //console.log("dataDict", dataDict);

      //create list of p_estimates to calculate extent
      let all_p_estimates = [];

      for (const key in dataDict) {
        if (dataDict.hasOwnProperty(key) && regions[columnValues.region].includes(key)) {
          const values = dataDict[key];
          all_p_estimates.push(values.p_estimate);
        }
      }

      // console.log("all p est", all_p_estimates);


      //updates text for all disability text for usa (this assumes the first selection is everyone with disability)
      d3.select("span#usa_p_estimate").text(`${dataDict["the United States"].p_estimate}%`);

      var states = topojson.feature(us, us.objects.states);     // List of state outlines to fill
      var statesMesh = topojson.mesh(us, us.objects.states);    // 'Mesh' of all outlines put together for a stroke

      //add names to each state
      states.features.forEach(d => {
        d.name = stateDict[d.id]
      });


      // MAP
      const projection = d3.geoMercator() //geoAlbersUsa() to see alaska
        .scale(1 / (2 * Math.PI))
        .translate([0, 0]);

      let render = d3.geoPath(projection);

      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = svgMap.append("g")
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      var data = []; //TODO: update this when data changes, colorScale will also be automatically updated
      let colors = d3.schemeBlues[9];
      let colorScaleState = d3.scaleQuantize(d3.extent(all_p_estimates), colors);

      let statePaths = svgMap.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)  // debugging
        .attr("d", render)
        .attr("fill", d => {
          if (d.name == "Virgin Islands") { return "none" } //we don't have data for Virgin Islands
          else { return colorScaleState(dataDict[d.name].p_estimate) }
        })
        .attr("opacity", 0.8)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState);

      let momesh = svgMap.append("path")
        .attr("class", "mouseover outline")
        .style("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .attr("d", "");

      //Mouseover interaction
      let tooltipWidth = 250;
      let tooltipHeight = 45;

      let tooltip = svgMap.append("g")
        .attr("class", "tooltip")
        .attr("transform", `translate(${20},20)`)
        .attr("visibility", "hidden");

      let box = tooltip.append("rect")
        .attr("fill", "white")
        .attr("opacity", 0.8)
        .attr("x", 0)
        .attr("y", 10)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 15);
      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 35);

      var state_datum = states.features[0]; //use this to store selected SVG element to use for zooming, initialized with first feature

      function mouseEntersState() {
        // Make tooltip visible
        tooltip.style("visibility", "visible")

        let state = d3.select(this);
        state_datum = state.datum();

        let stateID = state_datum.id;

        txt.text(state_datum.name);

        //store text2 so it's easier to adjust length
        let text2 = `${dataDict[state_datum.name].p_estimate}% (${d3.format(",")(dataDict[state_datum.name].n_estimate)})`;
        txt2.text(text2);

        let bounds = render.bounds(state.datum());
        let xPos = (state_datum.name === "Alaska") ? bounds[0][0] : (bounds[0][0] + bounds[1][0]) / 2;
        let yPos = bounds[1][1];

        box.attr("width", text2.length * 8.5);
        tooltip
          .attr("transform", `translate(${xPos},${yPos})`)



        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });

        momesh.datum(mo).attr("d", render)

      }

      function mouseLeavesState() {

        // Hide when you leave a state
        tooltip.style("visibility", "hidden");

        let state = d3.select(this);

        // hiding the mouseover mesh
        momesh.attr("d", "");

      }
      var zoom = d3.zoom()
        .scaleExtent([1 << 12, 1 << 20])
        .on("zoom", ({ transform }) => zoomed(transform));


      //centerLocation
      let centerCoordinates = {
        latitude: 41.4925,
        longitude: -99.9018
      };

      svgMap
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(- 1 << 12)
          .translate(...projection([centerCoordinates.longitude, centerCoordinates.latitude]))
          .scale(-1)
        )
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {
        // console.log("regular projection", projection([42.36541856, -71.05688332]))

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);


          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);

        });

        projection
          .scale(transform.k / (2 * Math.PI))
          .translate([transform.x, transform.y]);

        render = d3.geoPath(projection);

        //update state outlines
        statePaths.attr("d", render);

        //update hover path location
        momesh.attr("d", render);

        //update text location
        let bounds = render.bounds(state_datum);
        let xPos = (state_datum.name === "Alaska") ? bounds[0][0] : (bounds[0][0] + bounds[1][0]) / 2;
        let yPos = bounds[1][1];
        tooltip.attr("transform", `translate(${xPos},${yPos})`);

      };


      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      //calls update on filters when selections are changed
      function updateData() {


        statesData = statesAll.filter(function (row) {
          return (
            row.gender === columnValues.gender
            &&
            row.disability_type === columnValues.disabilityType
            &&
            row.age === columnValues.age &&
            row.race === columnValues.race &&
            row.education === columnValues.education &&
            row.hispanic === columnValues.hispanic
          )
        });

        //console.log(statesData);



        //console.log("dataDict before", dataDict)
        //refilters the states to be displayed
        statesData.forEach(d => {
          dataDict[d.state] = { n_estimate: d.n_estimate, p_estimate: d.p_estimate }
        });
        //console.log("dataDict after", dataDict)


        /******************* 
        Table Data 
        *******************/
        let goodData;
        if (plottingPrevalenceTable) {
          let dedupedStatesData = statesData.reduce((accumulator, currentLocation) => {
            if (!accumulator.tempLocations.includes(currentLocation.state)) {
              accumulator.tempLocations.push(currentLocation.state); // Add id to tempIds to track uniqueness
              accumulator.unique.push(currentLocation); // Add the current item to the unique list
            }
            return accumulator;
          }, { tempLocations: [], unique: [] }).unique;
          goodData = dedupedStatesData;

        } else {
          goodData = unstackDataset(statesData);
        }

        // no need to plot rows for things out of region. remove them here
        goodData = goodData.filter(d => {
          return regions[columnValues.region].includes(d.state);
        });

        currentTableData = [...goodData];
        updateTableRows(goodData);
        /******************* 
           End Table Data 
        *******************/

        // reevaluate all p_estimates, should only be states that are in selected region
        all_p_estimates = [];
        for (const key in dataDict) {
          if (dataDict.hasOwnProperty(key) && regions[columnValues.region].includes(key)) {
            const values = dataDict[key];
            all_p_estimates.push(values.p_estimate);
          }
        }

        // console.log("usa p est: ", dataDict["the United States"])


        colorScaleState = d3.scaleQuantize(d3.extent(all_p_estimates), colors);

        statePaths.attr("fill", d => {
          if (d.name == "Virgin Islands") d.color = "none" //we don't have data for Virgin Islands
          else if (columnValues.region == 0) {
            d.color = colorScaleState(dataDict[d.name].p_estimate)
          }
          else {
            if (regions[columnValues.region].includes(d.name)) {
              d.color = colorScaleState(dataDict[d.name].p_estimate)
            } else {
              d.color = "grey"
            }
          }
          return d.color
        })
          .attr("stroke", "grey");

        //dynamically fill description spans
        textColumns.forEach(d => {
          let value = key[d][Number(columnValues[d])];
          d3.select(`span#${d}`).text(value);
        })

        d3.select("span#dynamic_p_estimate").text(`${dataDict["the United States"].p_estimate}%`);


      }

      updateData();

    }

    requestMapData();

    // ---------------
    // HELPER FUNCTIONS
    // ---------------

    //key to match numbers to names, used to dynamically populate descriptions
    let key = {
      gender: {
        0: 'male or female',
        1: 'male',
        2: 'female'
      },
      disabilityType: {
        1: 'any',
        2: 'visual',
        3: 'hearing',
        4: 'ambulatory',
        5: 'cognitive',
        6: 'self-care',
        7: 'independent living'
      },
      age: {
        0: 'all ages',
        1: 'ages 4 and under',
        2: 'ages 5-15',
        3: 'ages 16-20',
        4: 'ages 21-64',
        5: 'ages 16-64',
        6: 'ages 18-64',
        7: 'ages 65-74',
        8: 'ages 65+',
        9: 'ages Ages 75+'
      },
      race: {
        0: 'all races',
        1: 'White',
        2: 'Black/African American',
        3: 'Native American or Alaska native',
        4: 'Asian',
        5: 'some other race(s)'
      },
      education: {
        0: 'all education levels',
        1: 'less than a high school education',
        2: 'a high school diploma or equivalent',
        3: 'some college/associates degree',
        4: 'a BA degree or higher'
      },
      hispanic: {
        0: 'regardless of ethnicity',
        1: 'Hispanic',
        2: 'non-Hispanic'
      }
    }

    //makes sure element shows up within bounds
    function elementLocation(mouseX, mouseY, elementWidth, elementHeight, boundaryX, xMargin, yMargin) {

      let xPos = mouseX + xMargin;
      let yPos = mouseY - yMargin - elementHeight;

      if ((xPos + elementWidth) > boundaryX) {
        xPos = mouseX - xMargin - elementWidth
      }
      if (yPos < 0) {
        yPos = mouseY - yMargin
      }

      return { x: xPos, y: yPos };

    }



  </script>

  <!-- ==================
        TABLE
    =================== -->
  <svg id="prevalenceTable" height="100" width="1200">

  </svg>
  <!-- ==================
        TABLE SCRIPT
    =================== -->
  <script>

    // --- We are going to make the table
    // Create the <svg> where it lives or select it
    // Make the extra g tags for annotations and lines and labels etc
    // Call updateTableRows on your data array to fill in each row

    // --- Someone pressed a sorting button
    // Re-sort the data array based on some criteria
    //  (e.g. now the lowest p_est is first instead of alphabetical by state)
    // Call updateTableRows again on the newly sorted dataset

    // -- Someone changed ANYTHING else in the filter panel etc
    // Just make sure that your data array has the right stuff in it
    // Then call updateTableRows
    const empSVG = d3.select("svg#prevalenceTable");
    const empSVGWidth = empSVG.attr("width");
    var currentEmpSVGHeight = empSVG.attr("height");
    const empSVGMargin = { top: 40, right: 30, bottom: 50, left: 130 };
    const empChartWidth = empSVGWidth - empSVGMargin.left - empSVGMargin.right;

    const rowHeight = 30;

    const maxBarLength = 250;
    var currentTableData;
    var subchartStartPos;
    const subchartMargin = 0.5;

    const tableCategories = ["Location", "Estimate (%)", "90% MOEp", "Estimate (number)", "90% MOEn", "Base Population", "Sample Size"];
    const tableGroups = ["Location", "Percent", "Number", "Base Population", "Sample Size"];

    const groupToCategories = {
      "Location": ["Location"],
      "Percent": ["Estimate (%)", "90% MOEp"],
      "Number": ["Estimate (number)", "90% MOEn"],
      "Base Population": ["Base Population"],
      "Sample Size": ["Sample Size"]
    }

    let activeTableGroups = [...tableGroups];
    let activeTableCategories = [...tableCategories];

    const locationStart = 0;
    const locationWidth = 175;

    const pEstimateStart = locationStart + locationWidth;
    const pEstimateWidth = 80;

    const pMoeStart = pEstimateStart + pEstimateWidth;
    const pMoeWidth = 80;

    const nEstimateStart = pMoeStart + pMoeWidth;
    const nEstimateWidth = 100;

    const nMoeStart = nEstimateStart + nEstimateWidth;
    const nMoeWidth = 80;

    const populationStart = nMoeStart + nMoeWidth;
    const populationWidth = 120;

    const sampleStart = populationStart + populationWidth;
    const sampleWidth = 90;

    const thousandFormatter = d3.format(",");
    const floatFormatter = d3.format(".1f");

    function customFormatter(value) {
      const formattedVal = d3.format(",")(value);
      return `Â±${formattedVal}`;
    }

    const barMargin = 5;
    const endCircleRadius = 10;

    const mouseOverLabelBoxHeight = 20;
    const mouseOverLabelBoxWidth = 75;

    const headerHeight = 50;
    const tableFontSize = 12;
    const textMargin = 10;

    const closeHeight = 30;
    const closeWidth = 40;
    const closeInnerBoxHeight = 20;
    const xMargin = 3;

    const tableSpacingDict = {};

    // syntax for this dict, value 0 is start pos, value 1 is width, value 2 is header name, value 3 is formatter for displaying the value
    tableSpacingDict[tableCategories[0]] = [locationStart, locationWidth, "state", null];
    tableSpacingDict[tableCategories[1]] = [pEstimateStart, pEstimateWidth, "p_estimate", null];
    tableSpacingDict[tableCategories[2]] = [pMoeStart, pMoeWidth, "p_estimate_moe", customFormatter];
    tableSpacingDict[tableCategories[3]] = [nEstimateStart, nEstimateWidth, "n_estimate", thousandFormatter];
    tableSpacingDict[tableCategories[4]] = [nMoeStart, nMoeWidth, "n_estimate_moe", customFormatter];
    tableSpacingDict[tableCategories[5]] = [populationStart, populationWidth, "base_population", thousandFormatter];
    tableSpacingDict[tableCategories[6]] = [sampleStart, sampleWidth, "sample_size", thousandFormatter];

    const tableGroupPositions = {}

    tableGroupPositions[tableGroups[0]] = [locationStart, locationWidth];
    tableGroupPositions[tableGroups[1]] = [d3.min([pEstimateStart, pMoeStart]), pEstimateWidth + pMoeWidth];
    tableGroupPositions[tableGroups[2]] = [d3.min([nEstimateStart, nMoeStart]), nEstimateWidth + nMoeWidth];
    tableGroupPositions[tableGroups[3]] = [populationStart, populationWidth];
    tableGroupPositions[tableGroups[4]] = [sampleStart, sampleWidth];

    // console.log(tableSpacingDict["Location"][3] != null);

    const percentScale = d3.scaleLinear()
      //.domain(empExtent)
      .domain([0, 100]) // for 0-100% scale vs. empExtent
      .range([0, maxBarLength]);

    // console.log(empChartWidth - (sampleStart + sampleWidth));





    // temp
    let drawWith = true;
    let drawWithout = true;
    let drawGap = true;
    // const loadEmpData = async function () {

    //   // ======        
    //   //  DATA
    //   // ======
    //   let empData = await d3.csv("acs_emp03.csv", d3.autoType)
    //   let goodData = unstackDataset(empData);
    //   console.log(goodData);

    //   let allWithout = d3.map(goodData, d => {
    //     return d["without"];
    //   })



    //   updateTableRows(goodData);
    // }

    function unstackDataset(stackedCSV) {
      // takes in the 104 stacked rows from the CSV 
      // returns 52 unstacked rows that have both "with" and "without" keys 
      //  for the matching p_estimates
      // RUN THIS FIRST TO MAKE A GOOD DATASET, THEN SORT AND EVERYTHING ELSE!

      let new_dataset = {};

      stackedCSV.forEach(d => {
        // check which kind of data it is
        let label = ""
        if (d.disability_type === 1) {
          label = "with";
        }
        else if (d.v2 === 2) {
          label = "without";
        }
        else {
          label = "NULL";
        }

        let location = d.location;
        if (location in new_dataset) {
          // update the row with the new value
          new_dataset[location][label] = d.p_estimate;
        }
        else
          new_dataset[location] = {
            "location": d.location,
            "sample_size": d.sample_size,
            "base_population": d.base_population,
            "n_estimate": d.n_estimate,
            "n_estimate_moe": d.n_estimate_moe,
            "p_estimate": d.p_estimate,
            "p_estimate_moe": d.p_estimate_moe,
            "id": d.id
          }
        new_dataset[location][label] = d.p_estimate;

      });

      // we need to convert from a dictionary back into a simple array
      return Object.values(new_dataset);

    }



    function updateTableRows(sorted_dataset) {

      recalculateTablePositions();
      subchartStartPos = calculateSubchartStartPosition();

      // get the height of the svg
      var requiredHeight = (sorted_dataset.length * rowHeight) + headerHeight + closeHeight + empSVGMargin.bottom;
      empSVG.attr("height", requiredHeight);
      currentEmpSVGHeight = empSVG.attr("height");


      empSVG.selectAll("g.tHeader").remove();
      addHeader(empSVG);

      empSVG.selectAll('g.row').remove();

      empSVG.selectAll('g.row')
        .data(sorted_dataset, d => d["state"])
        .join(enter => {
          let rows = enter.append("g").attr("class", "row");
          rows.attr("transform", (d, i) => `translate(0, ${empSVGMargin.top + headerHeight + i * rowHeight})`);

          // TODO add and configure the text part including their x position
          //   y position should always take into account the translate above
          rows.append("line")
            .attr("class", "tableSeperator")
            .attr("x1", 0)
            .attr("x2", subchartStartPos + maxBarLength)
            .attr("y1", 0)
            .attr("y2", 0)

          activeTableCategories.forEach(cat => {

            rows.append("text")
              .attr("class", `tableText ${cat}`)
              .text(d => {
                let displayText;
                if (d[tableSpacingDict[cat][2]] == "the United States") {
                  displayText = "United States";
                } else {
                  displayText = d[tableSpacingDict[cat][2]];
                }

                if (tableSpacingDict[cat][3] != null) {
                  return tableSpacingDict[cat][3](displayText);
                }
                return displayText;
              })
              .attr("x", d => {
                if (cat == tableCategories[0]) {
                  return tableSpacingDict[cat][0] + textMargin;
                }
                return tableSpacingDict[cat][0] + tableSpacingDict[cat][1] - textMargin;
              })
              .attr("y", rowHeight / 2);
          });


          let subcharts = rows.append("g")
            .attr("class", "empSVG")
            .attr("transform", `translate(${subchartStartPos + subchartMargin}, 0)`)
          // shift the chart over a bit so its on right side


          subcharts.each(updateEmpSvg)

        },
          update => {
            update.transition() // animate them shuffling around???
              .attr("transform", (d, i) => `translate(0, ${i * rowHeight})`);

            // select and update each of the text elements as necessary
            //  (this is why it's important to add classes in enter)
            update.select("text.p_est")
              .text(d => d['p_est']);
            // ... append other text inside of the rows

            // select and update the fancy sub-chart
            //  (this is why it's important to add classes in enter)
            let subcharts = update.selectAll("g.empSVG")

            // but how do we get each of the charts to have the right contents?
            //  ... and, how do we make sure they update properly
            subcharts.each(updateEmpSvg)

          },
          exit => {
            exit.transition()
              .attr("opacity", 0)
              .remove()
          });
    }

    function updateEmpSvg(d, i) {
      // expects to get one point of data from your array
      // e.g. d={'with_est':,'without_est':}

      // console.log("updateEmpSvg", i, d);

      let empSVG = d3.select(this);

      if (drawWithout && !plottingPrevalenceTable) {
        let lightBlueLine = empSVG.selectAll("rect.withoutBar")
          .data([d])
          .join( // make new bar without animation
            enter => enter.append("rect")
              .attr("class", "withoutBar")
              .attr("x", 0)
              .attr("y", barMargin)
              .attr("width", d => percentScale(d.without))
              .attr("height", rowHeight - 2 * barMargin)
              .on("mouseover", d => { })
            ,
            // update bar with moving line animations
            // for animation, add .call
            update => update.call(update =>
              update.transition()
                .attr("width", d => percentScale(d.without))
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            });
      }

      if (drawWith) {
        let darkBlueLine = empSVG.selectAll("rect.withBar")
          .data([d])
          .join( // make new bar without animation
            enter => enter.append("rect")
              .attr("class", "withBar")
              .attr("x", 0)
              .attr("y", barMargin)
              .attr("width", d => {
                if (plottingPrevalenceTable) {
                  return percentScale(d.p_estimate);
                }
                return percentScale(d.with);
              })
              .attr("height", rowHeight - 2 * barMargin)
              .on("mouseover", d => { })
            ,
            // update bar with moving line animations
            // for animation, add .call
            update => update.call(update =>
              update.transition()
                .attr("width", d => {
                  if (plottingPrevalenceTable) {
                    return percentScale(d.p_estimate);
                  }
                  return percentScale(d.with);
                })
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            });
        let darkBlueCircle = empSVG.selectAll("circle.withEndCircle")
          .data([d])
          .join(
            enter => enter.append("circle")
              .attr("class", "withEndCircle")
              .attr("cx", d => {
                if (plottingPrevalenceTable) {
                  return percentScale(d.p_estimate);
                }
                return percentScale(d.with);
              })
              .attr("cy", rowHeight / 2)
              .attr("r", endCircleRadius)
              .attr("rowIndex", i)
              .on("mouseover", circleHover)
              .on("mouseleave", circleUnhover)
            ,

            update => update.call(update =>
              update.transition()
                .attr("cx", d => {
                  if (plottingPrevalenceTable) {
                    return percentScale(d.p_estimate);
                  }
                  return percentScale(d.with);
                })
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            })
      }


      if (drawWithout && !plottingPrevalenceTable) {
        let lightBlueCircle = empSVG.selectAll("circle.withoutEndCircle")
          .data([d])
          .join(
            enter => enter.append("circle")
              .attr("class", "withoutEndCircle")
              .attr("cx", d => percentScale(d.without))
              .attr("cy", rowHeight / 2)
              .attr("r", endCircleRadius)
              .attr("rowIndex", i)
              .on("mouseover", circleHover)
              .on("mouseleave", circleUnhover)
            ,

            update => update.call(update =>
              update.transition()
                .attr("cx", d => percentScale(d.without))
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            })

      }
      if (drawGap && !plottingPrevalenceTable) {

        let gapText = empSVG.selectAll("text.gapText")
          .data([d])
          .join(
            enter => enter.append("text")
              .attr("class", "tableText gapText")
              .attr("x", empChartWidth - (sampleStart + sampleWidth))
              .attr("y", rowHeight / 2)
              .text(d => floatFormatter(d.without - d.with) + "%")
          );
      }

    }

    function circleHover(event, d) {
      // console.log(event, d);
      let circle = d3.select(this)
        .attr("r", endCircleRadius * 1)
        .style("fill", "white")
        .attr("stroke", "black")
        .attr("stroke-width", "8px");



      let xPos = Number(circle.attr("cx")) + subchartStartPos;
      let yPos = Number(circle.attr("cy")) + headerHeight + rowHeight * circle.attr("rowIndex");

      let g = empSVG.append("g")
        .attr("transform", `translate(${xPos - mouseOverLabelBoxWidth / 2}, ${yPos})`)
        .attr("class", "mouseOverLabel")
        .style("pointer-events", "none")
      g.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", mouseOverLabelBoxWidth)
        .attr("height", mouseOverLabelBoxHeight)
        .attr("fill", "white")
        .attr("stroke", "black")
      g.append("text")
        .attr("x", mouseOverLabelBoxWidth / 2)
        .attr("y", mouseOverLabelBoxHeight / 2)
        .attr("font-size", tableFontSize + "px")
        .attr("dominant-baseline", "middle")
        .attr("text-anchor", "middle")
        .text("Rate: " + d.p_estimate + "%")
    }

    function circleUnhover(event, d) {
      d3.select(this)
        .attr("r", endCircleRadius)
        .style("fill", "")
        .attr("stroke", "none")
        .attr("stroke-width", "0px");

      empSVG.select(".mouseOverLabel").remove() // find the thing with the class and remove it
    }

    function addHeader(target) {
      var headerGroup = target.append("g")
        .attr("class", "tHeader")
        .attr("transform", `translate(${0}, ${empSVGMargin.top})`);

      activeTableGroups.forEach(group => {
        //add group seperators

        headerGroup.append("line")
          .attr("class", "groupLines")
          .attr("x1", tableGroupPositions[group][0] + tableGroupPositions[group][1])
          .attr("x2", tableGroupPositions[group][0] + tableGroupPositions[group][1])
          .attr("y1", headerHeight)
          .attr("y2", currentEmpSVGHeight - rowHeight - empSVGMargin.bottom)
          .attr("stroke-width", 1)
          .attr("stroke", "black")
          .raise();

        headerGroup.append("rect")
          .attr("class", `tableHeaderBox ${group}`)
          .attr("x", tableGroupPositions[group][0])
          .attr("width", tableGroupPositions[group][1])
          .attr("height", headerHeight);



        var closeButtonGroup = headerGroup.append("g").attr("class", `closeGroup ${group}`).datum(group);
        if (group != tableGroups[0]) {
          let closeProtrusion = closeButtonGroup.append("rect")
            .attr("class", `tableHeaderBox closeProtrusion ${group}`)
            .attr("x", tableGroupPositions[group][0] + tableGroupPositions[group][1] - closeWidth)
            .attr("y", -closeHeight)
            .attr("width", closeWidth)
            .attr("height", closeHeight)
            .on("click", closeGroup);


          let closeSquare = closeButtonGroup.append("rect")
            .attr("class", `closeSquare`)
            .attr("x", Number(closeProtrusion.attr("x")) + (closeWidth) / 4)
            .attr("y", -closeInnerBoxHeight)
            .attr("width", closeWidth / 2)
            .attr("height", closeInnerBoxHeight)
            .on("click", closeGroup);

          closeButtonGroup.append("line")
            .attr("class", `closeX`)
            .attr("x1", Number(closeSquare.attr("x")) + xMargin)
            .attr("x2", Number(closeSquare.attr("x")) + (closeWidth / 2) - xMargin)
            .attr("y1", -closeInnerBoxHeight + xMargin)
            .attr("y2", - xMargin)
            .attr("stroke", "black")
            .on("click", closeGroup);


          closeButtonGroup.append("line")
            .attr("class", `closeX`)
            .attr("x2", Number(closeSquare.attr("x")) + xMargin)
            .attr("x1", Number(closeSquare.attr("x")) + (closeWidth / 2) - xMargin)
            .attr("y1", -closeInnerBoxHeight + xMargin)
            .attr("y2", -xMargin)
            .attr("stroke", "black")
            .on("click", closeGroup);

        } else {
          //aka this is location
          closeButtonGroup.append("text")
            .attr("class", "resetText")
            .attr("x", 0)
            .attr("y", -closeHeight + (tableFontSize))
            .text("RESET TABLE")
            .on("click", resetTable);
        }

      });

      activeTableCategories.forEach(cat => {
        const headerText = headerGroup.append("text")
          .attr("class", `tHeaderText tableText ${cat}`)
          .attr("x", tableSpacingDict[cat][0] + (textMargin))
          .attr("y", (rowHeight / 2) - (1.5 * tableFontSize));


        const words = cat.split(" ");
        if (words.length > 1) {
          words.forEach((word, index) => {
            headerText.append("tspan")
              .attr("x", tableSpacingDict[cat][0] + (tableSpacingDict[cat][1]) - textMargin)
              .text(word)
              .attr("dy", 1.5 * tableFontSize)
          });
        } else {
          headerText.text(cat).attr("y", (rowHeight / 2) + 18);
        }



      });

      return headerGroup;
    }
    function closeGroup(event, d) {
      if (activeTableGroups.includes(d)) {
        activeTableGroups.splice(activeTableGroups.indexOf(d), 1);
      }
      let catsToRemove = groupToCategories[d];
      catsToRemove.forEach(c => {
        if (activeTableCategories.includes(c)) {
          activeTableCategories.splice(activeTableCategories.indexOf(c), 1);
        }
      });

      updateTableRows(currentTableData);

      console.log(activeTableGroups);

    }

    function resetTable(event, d) {
      console.log("Active before reset stuff", activeTableGroups, activeTableCategories);
      activeTableCategories = [...tableCategories];
      activeTableGroups = [...tableGroups];
      updateTableRows(currentTableData);

      console.log("Active stuff now", activeTableGroups, activeTableCategories);
    }

    function recalculateTablePositions() {
      let currentPosition = 0;

      tableGroups.forEach(group => {
        if (activeTableGroups.includes(group)) {
          // Calculate the total width of the group based on active categories
          let groupWidth = 0;
          const categories = groupToCategories[group];
          categories.forEach(cat => {
            if (activeTableCategories.includes(cat)) {
              groupWidth += tableSpacingDict[cat][1]; // Add the width of each active category
            }
          });

          tableGroupPositions[group] = [currentPosition, groupWidth];
          categories.forEach(cat => {
            if (activeTableCategories.includes(cat)) {
              tableSpacingDict[cat][0] = currentPosition;
              currentPosition += tableSpacingDict[cat][1]; // Move the current position by the width of the category
            }
          });
        }
      });
    }

    function calculateSubchartStartPosition() {
      // Calculate the rightmost edge of the last active group
      let lastGroupEdge = 0;
      activeTableGroups.forEach(group => {
        const groupPosition = tableGroupPositions[group];
        if (groupPosition) {
          const groupEdge = groupPosition[0] + groupPosition[1]; // Start + width
          lastGroupEdge = Math.max(lastGroupEdge, groupEdge);
        }
      });

      return lastGroupEdge;
    }
    // loadEmpData();



  </script>

</body>