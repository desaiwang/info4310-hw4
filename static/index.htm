<html>

<head>
  <title>INFO 4310 - HW4</title>
  <link href="./style.css" rel="stylesheet" type="text/css">
  <link rel="icon" href="favicon3.svg">
  <!-- <link href="./style.css" rel="stylesheet" type="text/css"> -->

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <style>
    body {
      font-family: 'Barlow', 'Helvetica', sans-serif;
      font-weight: 400;
      margin: 0;
      padding: 0;
      /* min-width: 1300px;
      max-width: 1400px;
      overflow-x: scroll;
      overflow-y: hidden;
      overscroll-behavior-x: none; */
    }

    title {
      display: block;
      font-weight: 400;
      font-size: 1.65em;
      padding: 0;
      margin: 0;
      color: #1059C9;
    }

    h1 {
      font-weight: 700;
      font-size: 2.75em;
      margin: 0;
      padding: 0;
      color: #1059C9;
    }

    h2 {
      font-weight: 700;
      font-size: 1em;
      margin: 0;
      padding: 20px 0 0 0;
      color: black;
    }

    h3 {
      font-size: 1em;
      font-weight: 700;
      padding: 0 0 10px 0;
      margin: 0 0 20px 0;
      color: #1059C9;
      border-bottom: 1px solid #1059C9;
      border-bottom-style: dotted;
    }

    h4 {
      font-weight: 600;
      font-size: 1.5em;
      padding: 0 0 25px 0;
      margin: 0;
      color: black;
    }

    a {
      color: #1059C9;
      text-decoration: underline;
      text-decoration-style: dashed;
      text-underline-offset: 4px;
    }

    a:hover {
      color: #1059C9;
      text-decoration: underline;
      text-decoration-style: solid;
      text-underline-offset: 4px;
    }

    p {
      margin: 0;
      padding: 3px 0;
      line-height: 1.3em;
    }

    .quickFacts {
      width: 1000px;
      font-weight: 500;
      font-size: 2.4em;
      /* margin: 0; */
      margin: 0 0 20px 0;
      padding: 0;
      color: black;
    }

    ul.quickFacts {
      margin: 0 0 15px 60px;
      line-height: 1.3em;
    }
    #controlfilter{
      margin-top: 2em;
      height: 70px;
      width: 750px;
    }

    .withColor {
      color: #E1195F;
      font-weight: 800;
    }

    .withoutColor {
      color: #1059C9;
      font-weight: 800;
    }

    .gapColor {
      color: #F96706;
      font-weight: 800;
    }

    .gapHighlight,
    .withHighlight,
    .withoutHighlight {
      text-decoration: underline;
      text-underline-offset: 5px;
    }

    .withHighlight {
      text-decoration-color: #E1195F;
    }

    .withoutHighlight {
      text-decoration-color: #1059C9;
    }

    .gapHighlight {
      text-decoration-color: #F96706;
    }

    p.mapTitle {
      font-weight: 500;
      font-size: 1.3em;
      margin: 0 0 1.3em 0;
    }

    button#toggle {
      display: block;
      border: 0;
      background-color: #5396E8;
      color: white;
      width: 70px;
      padding: 7px 0;
      font-size: .8em;
    }

    button#toggleSearch {
      display: block;
      border: 0;
      background-color: #5396E8;
      color: white;
      width: 70px;
      padding: 7px 0;
      font-size: .8em;
    }

    /* =======
         GRID 
       ======= */
    /* MAIN CONTAINER */
    #container {
      display: grid;
      min-width: 100vw;
      height: 100vh;
      grid-template-columns: 70px 320px 1fr;
      grid-template-rows: auto auto 245px auto .5fr 1fr 1fr;
      gap: 0 50px;
      grid-auto-flow: row;
      grid-template-areas:
        "masthead masthead masthead"
        "pageTitle pageTitle pageTitle"
        "dir1 quickStat quickStat"
        "dir2 filters map"
        "dir2 filters brush"
        "dir3 tableBar tableBar"
        ". footer footer";
      transition: 1s;
    }

    /* child of #container: MASTHEAD CONTAINER */
    .masthead {
      display: grid;
      grid-template-columns: 75px 300px 1fr;
      grid-template-rows: 100px;
      gap: 0px 20px;
      height: 100px;
      grid-template-areas: "logo siteName indStat";
      grid-area: masthead;
      align-items: center;
      position: sticky;
      /* keeps masthead stuck to top of screen */
      z-index: 1000;
      top: 0;
      padding: 0 0 0 120px;
      background-color: white;
    }

    /* children of masthead */
    .logo {
      grid-area: logo;
      padding: 0;
      text-align: left;
    }

    .siteName {
      grid-area: siteName;
    }

    .indStat {
      grid-area: indStat;
    }

    /* LEFT COLUMN (possibly for directions) */
    .dir0 {
      grid-area: dir0;
      background-color: white;
    }

    .dir1 {
      grid-area: dir1;
      background-color: #1059C9;
    }

    .dir2 {
      grid-area: dir2;
    }

    .dir3 {
      grid-area: dir3;
    }

    /* full row for PAGE TITLE */
    .pageTitle {
      grid-area: pageTitle;
      position: sticky;
      z-index: 999;
      top: 100px;
      background-color: white;
      height: 100px;
      padding: 10px 0 0 120px;
    }

    .quickStat {
      grid-area: quickStat;
      /* padding: 20px 0 40px 0;  */
      background-color: white;
      min-height: 0;
      margin: 0 150px 0 0;
      overflow: hidden;
    }

    /* setting for collapsed state of quick stats triggered by "CLOSE STATS" button" */
    #container.collapsedQuickStats {
      grid-template-rows: auto auto 0 auto .5fr 1fr 1fr;
      padding: 0;
      margin: 0;
    }

    .filters {
      grid-area: filters;
      margin: 143px 50px 0 0;
      min-width: 0;
      overflow: hidden;
    }

    /* setting for collapsed state of search filters triggered by "CLOSE SEARCH" button" */
    #container.collapsedFilters {
      grid-template-columns: 70px 0 1fr;
      padding: 0;
      margin: 0;
    }

    .map {
      grid-area: map;
      margin: 40px 150px 0 -50px;
      min-width: 1200px;
      min-height: 800px;
      overflow: hidden;
    }

    .brush {
      grid-area: brush;
    }

    .tableBar {
      grid-area: tableBar;
      margin: 30px 150px 0 0;
    }

    .footer {
      grid-area: footer;
      min-height: 300px;
    }

    /* CUSTOM SELECT FORMATTING */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    select {
      appearance: none;
      background-color: transparent;
      border: none;
      padding: 0 1em 0 0;
      margin: 0;
      width: 100%;
      font-family: inherit;
      font-size: inherit;
      cursor: inherit;
      line-height: inherit;
      z-index: 1;
      outline: none;
    }

    select::-ms-expand {
      display: none;
    }

    /* Filter selects */
    .select {
      display: grid;
      grid-template-areas: "select";
      align-items: center;
      position: relative;
      border: 1px solid #1059C9;
      border-radius: 1em;
      padding: .5em .75em;
      margin: 0;
      font-size: rem;
      /* text-shadow: 2px 2px; */
      cursor: pointer;
      line-height: 1.3;
      color: black;
      background-image: linear-gradient(to top, #ddd, #fff 50%);
    }

    /* GRID for the INDIVIDUAL STATISTIC in masthead */
    .indStatGrid {
      display: grid;
      grid-template-columns: 70px auto;
      grid-template-rows: auto;
      gap: 0 20px;
      grid-template-areas: "indStatLabel indStatSelect";
      grid-area: indStatGrid;
      align-items: center;
    }

    .indStatLabel {
      grid-area: indStatLabel;
      padding: 2px 0 0 0;
    }

    .indStatSelect {
      grid-area: indStatSelect;
      padding: 2px 0 0 0;
    }

    /* INDIVIDUAL STATISTIC select */
    .selectIndStat {
      display: grid;
      grid-template-areas: "select";
      align-items: center;
      position: relative;
      border: 1px solid #E1195F;
      border-radius: 1em;
      padding: .5em .75em .5em .75em;
      margin: 0;
      font-size: 1rem;
      cursor: pointer;
      line-height: 1.3;
      color: black;
      background-image: linear-gradient(to top, #ddd, #fff 50%);
      width: 300px;
    }

    .select select,
    .select::after,
    .selectIndStat select,
    .selectIndStat::after {
      grid-area: select;
    }

    /* style triangle */
    .select::after,
    .selectIndStat::after {
      content: "";
      justify-self: end;
      width: 0.8em;
      height: 0.5em;
      background-color: #5396E8;
      clip-path: polygon(100% 0%, 0 0%, 50% 100%);
    }

    .selectIndStat::after {
      content: "";
      justify-self: end;
      width: 0.8em;
      height: 0.5em;
      background-color: #E1195F;
      clip-path: polygon(100% 0%, 0 0%, 50% 100%);
    }

    .select:hover,
    .selectIndStat:hover {
      border: 1px solid #E1195F;
    }

    .select:hover::after,
    .selectIndStat:hover::after {
      background-color: #E1195F;
      clip-path: polygon(100% 0%, 0 0%, 50% 100%);
      transform: rotate(-.5turn);
      transition-duration: .5s;
    }

    select:focus+.focus {
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      bottom: -1px;
      border: 2px solid #E1195F;
      border-radius: inherit;
    }

    label {
      display: block;
      font-size: 1em;
      font-weight: 700;
      margin: 5px .75em;
    }

    .indStatLabel label {
      font-weight: 500;
      margin: 0;
      padding: 0;
    }

    .select+label {
      margin-top: 1rem;
    }


    #content {
      display: grid;
      grid-template-rows: 0fr;
      transition: 1s;
      overflow: hidden;
    }

    #content .inside {
      min-height: 0;
    }

    #content.expanded {
      background: red;
      grid-template-rows: 1fr;
    }
  </style>
</head>
<body>

  <div id="container">
    <div class="dir0"></div>
    <div class="masthead">
      <div class="logo"><img src="logo.svg" height="75px"></div>
      <div class="siteName">
        <title>Disability Statistics</title>
      </div>
      <div class="indStat">

        <!-- Grid containing label and menu to pick individual statistic -->
        <div class="indStatGrid">
          <div class="indStatLabel"><label for="indStat">STATISTIC:</label></div>
          <div class="indStatSelect">
            <!-- Select Menu -->
            <div class="selectIndStat">
              <select id="indStat" name="indStat">
                <option value="0">PREVALENCE</option>
                <option value="1" selected>EMPLOYMENT RATE</option>
                <option value="2">POVERTY</option>
              </select>
              <span class="focus"></span>
            </div>

          </div>
        </div>

      </div>
    </div>
    <div class="pageTitle">
      <h1 id="pageTitle">EMPLOYMENT RATE</h1>
    </div>
    <div class="dir1"></div>
    <div class="quickStat">
      <h3>QUICK STATS</h3>
      <p class="quickFacts">
        <!-- TODO: should we also have a poverty gap? but what would we do for prevalence? -->
        In 2022, the national employment rate for people <span class="withHighlight">with</span> disabilities
        was <span class="withColor">45.0%</span> compared to <span class="withoutColor">81.0%</span> for people <span
          class="withoutHighlight">without</span> disabilities, an <span class="gapHighlight">employment gap</span> of
        <span class="gapColor">36.0%</span>.
      </p>
      2022 AMERICAN COMMUNITY SURVEY
      <!-- &nbsp;&nbsp;|&nbsp;&nbsp;<a href="">EMPLOYMENT RATE DEFINITION</a> -->
    </div>
    <div class="dir2">
      <button id="toggle">CLOSE STATS</button>

      <button id="toggleSearch" style="margin-top: 125px;">CLOSE SEARCH</button>

    </div>
    <div class="filters">
      <!--  ---------------
              FILTERS 
          --------------- -->

      <h3>SEARCH</h3>
      <!-- <button id="selectAllButton" value="selectAll">SELECT ALL</button>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<buttoncid="resetButton" value="reset">CLEAR ALL</button> -->

      <label for="region">REGION</label>
      <div class="select">
        <select id="region" name="region">
          <option value="0" selected>All Regions</option>
          <option value="1">Northeast</option>
          <option value="2">Midwest</option>
          <option value="3">South</option>
          <option value="4">West</option>
        </select>
        <span class="focus"></span>
      </div>
      <div id = "mapTypeAll">
        <label for="mapType">MAP TYPE</label>
        <div class="select">
          <select id="mapType" name="mapType">
            <option value="0">With or Without Disability</option>
            <option value="1" selected>With Disability</option>
            <option value="2">Without Disability</option>
          </select>
          <span class="focus"></span>
        </div>
      </div>

      <label for="disabilityType">DISABILITY TYPE</label>
      <div class="select">
        <select id="disabilityType" name="disabilityType">
          <option value="1" selected>Any Disability</option>
          <option value="2">Visual Disability</option>
          <option value="3">Hearing Disability</option>
          <option value="4">Ambulatory Disability</option>
          <option value="5">Cognitive Disability</option>
          <option value="6">Self-Care Disability</option>
          <option value="7">Independent Living Disability</option>
        </select>
        <span class="focus"></span>
      </div>

      <div id = "genderAll">
      <label for="gender">GENDER</label>
      <div class="select">
        <select id="gender" name="gender">
          <option value="0" selected>Male or Female</option>
          <option value="1">Males</option>
          <option value="2">Females</option>
        </select>
        <span class="focus"></span>
      </div>
    </div>

      <label for="age">AGE</label>
      <div class="select">
        <select id="age" name="age">
          <option value="0">All Ages</option>
          <option value="5">Ages 4 and under</option>
          <option value="6">Ages 5-15</option>
          <option value="1">Ages 16-20</option>
          <option value="2" selected>Ages 21-64</option>
          <option value="3">Ages 16-64</option>
          <option value="4">Ages 18-64</option>
          <option value="7">Ages 65-74</option>
          <option value="9">Ages 65+</option>
          <option value="8">Ages 75+</option>
        </select>
        <span class="focus"></span>
      </div>
      
      <div id = "raceAll">
      <label for="race">RACE</label>
      <div class="select">
        <select id="race" name="race">
          <option value="0" selected>All races</option>
          <option value="1">White</option>
          <option value="2">Black/African American</option>
          <option value="3">Native American or Alaska Native</option>
          <option value="4">Asian</option>
          <option value="5">Some other race(s)</option>
        </select>
        <span class="focus"></span>
      </div>
    </div>

      <div id = "edAll">
      <label for="education">EDUCATION</label>
      <div class="select">
        <select id="education" name="education">
          <option value="0" selected>All education levels</option>
          <option value="1">Less than a high school education</option>
          <option value="2">A high school diploma or equivalent</option>
          <option value="3">Some college/associates degree</option>
          <option value="4">A BA degree or higher</option>
        </select>
        <span class="focus"></span>
      </div>
    </div>
      <div id = "hispAll">
      <label for="hispanic">HISPANIC</label>
      <div class="select">
        <select id="hispanic" name="hispanic">
          <option value="0" selected>Regardless of ethnicity</option>
          <option value="1">Hispanic</option>
          <option value="2">Non-Hispanic</option>
        </select>
        <span class="focus"></span>
      </div>
    </div>

    </div>
    <div class="map">
      <!--  ---------------
                 MAP 
            --------------- -->
      <h3>MAP</h3>
      <h4 id="headingtext">EMPLOYMENT RATE: <br>The employment rate for non-institutionalized,
        <span id="gender">male or female</span>,
        with <span id="disabilityType">any</span> disability,
        <span id="age">all ages</span>,
        <span id="race">all races</span>,
        <span id="hispanic">regardless of ethnicity</span>,
        with <span id="education"></span> in the Unites States is <span id="dynamic_p_estimate">45%</span> in 2022.
      </h4>
      <!-- MAP -->
      <svg id="svgMap" width="1600" height="800" top="10"></svg>
    </div>
    <div class="brush" id = "controlfilter"></div>
    <div class="dir3"></div>
    <div class="tableBar">
      <!--  ---------------
                 TABLE
            --------------- -->
      <h3>TABLE</h3>
      <svg id="prevalenceTable" height="100" width="1200"></svg>
      <input type="checkbox" class="legendBox" id="withBox" name="withCheckbox">
      <input type="checkbox" class="legendBox" id="withoutBox" name="withoutCheckbox">
      <input type="checkbox" class="legendBox" id="gapBox" name="gapCheckbox">


    </div>
    <div class="footer"></div>
  </div>

  <!--  =======================
        SHOW/HIDE FILTER SCRIPT
        ======================= -->
  <script id="toggleScript">
    // toggle view of quick stats
    toggle.onclick = () => {
      container.classList.toggle("collapsedQuickStats");
      // Check if the button text is "CLOSE STATS"
      if (toggle.textContent === "CLOSE STATS") {
        // If so, change it to "OPEN STATS"
        toggle.textContent = "OPEN STATS";
      } else {
        // Otherwise, change it back to "CLOSE"
        toggle.textContent = "CLOSE STATS";
      }
    };

    // toggle view of search filters
    toggleSearch.onclick = () => {
      container.classList.toggle("collapsedFilters");
      // Check if the button text is "CLOSE SEARCH"
      if (toggleSearch.textContent === "CLOSE SEARCH") {
        // If so, change it to "OPEN SEARCH"
        toggleSearch.textContent = "OPEN SEARCH";
      } else {
        // Otherwise, change it back to "CLOSE SEARCH"
        toggleSearch.textContent = "CLOSE SEARCH";
      }
    };
  </script>

  <!--  =======================
               MAP SCRIPT
        ======================= -->
  <script id="map">
    const svgMap = d3.select("#svgMap");
    const width = svgMap.attr("width");
    const height = svgMap.attr("height");
    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/ckttxzrvq0s4i18l4he5vtltt/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`

    //set up colors 
    const selectedColor = "#7339D0";
    const greyedoutColor = "#A5A0AC";

    let plottingPrevalenceTable = true;


    const requestMapData = async () => {

      let regions = {
        0: [
          "the United States",
          "Alabama",
          "Alaska",
          "Arizona",
          "Arkansas",
          "California",
          "Colorado",
          "Connecticut",
          "Delaware",
          "Florida",
          "Georgia",
          "Hawaii",
          "Idaho",
          "Illinois",
          "Indiana",
          "Iowa",
          "Kansas",
          "Kentucky",
          "Louisiana",
          "Maine",
          "Maryland",
          "Massachusetts",
          "Michigan",
          "Minnesota",
          "Mississippi",
          "Missouri",
          "Montana",
          "Nebraska",
          "Nevada",
          "New Hampshire",
          "New Jersey",
          "New Mexico",
          "New York",
          "North Carolina",
          "North Dakota",
          "Ohio",
          "Oklahoma",
          "Oregon",
          "Pennsylvania",
          "Rhode Island",
          "South Carolina",
          "South Dakota",
          "Tennessee",
          "Texas",
          "Utah",
          "Vermont",
          "Virginia",
          "Washington",
          "West Virginia",
          "Wisconsin",
          "Wyoming",
          "Puerto Rico"
        ],
        1: ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'New Jersey', 'New York', 'Pennsylvania', 'Rhode Island', 'Vermont'],
        2: ['Illinois', 'Indiana', 'Iowa', 'Kansas', 'Michigan', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'Ohio', 'South Dakota', 'Wisconsin'],
        3: ['Alabama', 'Arkansas', 'Delaware', 'District of Columbia', 'Florida', 'Georgia', 'Kentucky', 'Louisiana', 'Maryland', 'Mississippi', 'North Carolina', 'Oklahoma', 'South Carolina', 'Tennessee', 'Texas', 'Virginia', 'West Virginia'],
        4: ['Alaska', 'Arizona', 'California', 'Colorado', 'Hawaii', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Oregon', 'Utah', 'Washington', 'Wyoming']
      }

      //these are columns that affect text
      let columnsDict = {
        0: ["disabilityType", "gender", "age", "race", "education", "hispanic"], //prevalence
        1: ["mapType", "disabilityType", "gender", "age", "race", "education", "hispanic"], //employment rate
        2: ["mapType", "disabilityType", "age"] //poverty rate
      }

      //initialize dict with column values
      let columnValues = {
        indStat: 1, //initialize with employment rate
        mapType: 1, //initialize as "with disability"
        gender: 0,
        disabilityType: 1,
        age: 2, //initialize as 21-64 
        race: 0,
        education: 0,
        hispanic: 0,
        region: 0
      };

      //state data (filter based on selected)
      let prevalenceAll = await d3.csv("./acs_prevalence2.csv", d3.autoType);
      let employmentAll = await d3.csv("./acs_employment_rate2.csv", d3.autoType);
      let povertyAll = await d3.csv("./acs_poverty2.csv", d3.autoType);

      const datasetsDict = {
        0: prevalenceAll,
        1: employmentAll,
        2: povertyAll
      };
      //TODO: also need to change headers accordingly!

      let statesData = datasetsDict[columnValues.indStat].filter(function (row) {
        for (let d of columnsDict[columnValues.indStat]) {
          if (row[d] !== columnValues[d]) {
            //console.log("d: ", d);
            //console.log("row[d]: ", row[d])
            //console.log("columnValues[d]: ", columnValues[d])
            return false; // Exit the loop and filter immediately if a mismatch is found
          }
        }
        return true; // Return true only if all filter conditions are met
      });

      //console.log(`getting ${columnValues.indStat} from datasetDict: `, datasetsDict[columnValues.indStat]);
      //console.log(`trying to test these column values: ${columnsDict[columnValues.indStat]}`)
      //console.log('statesData', statesData);

      //setting up selections to track changes
      let allColumns = ["region", "mapType", "disabilityType", "gender", "age", "race", "education", "hispanic"];
      allColumns.forEach((d) => {
        d3.select(`select#${d}`)
          .on("change", function () {
            columnValues[d] = Number(d3.select(this).property("value"));
            console.log(`${d} changed, logging column values:`, columnValues);

            updateData();
          });
      });

      //indstat tracked separately, since age value needs to be reset
      d3.select(`select#indStat`)
        .on("change", function () {
          columnValues.indStat = Number(d3.select(this).property("value"));
          //console.log(`indStat changed, logging column values:`, columnValues);

          if (columnValues.indStat === 0) {
            //prevalence
            columnValues.age = 0

            d3.select("h1#pageTitle").text("PREVALENCE");
            d3.select(`label#mapType`).style("display", "none");
            d3.select(`select#mapType`).style("display", "none");
            d3.select(`#mapTypeAll`).style("display", "none");
            d3.select(`#genderAll`).style("display", "block");
            d3.select(`#raceAll`).style("display", "block");
            d3.select(`#edAll`).style("display", "block");
            d3.select(`#hispAll`).style("display", "block");




            //TODO: natalia for hiding selections
            //d3.select(`label#mapType`).style("display", "none");
            //d3.select(`select#mapType`).style("display", "none");
          } else if (columnValues.indStat === 1) {
            //employment
            columnValues.age = 2
            d3.select("h1#pageTitle").text("EMPLOYMENT RATE");
            d3.select(`label#mapType`).style("display", "block");
            d3.select(`select#mapType`).style("display", "block");
            d3.select(`#mapTypeAll`).style("display", "block");
            d3.select(`#genderAll`).style("display", "block");
            d3.select(`#raceAll`).style("display", "block");
            d3.select(`#edAll`).style("display", "block");
            d3.select(`#hispAll`).style("display", "block");





          } else {
            //poverty
            columnValues.age = 2
            d3.select("h1#pageTitle").text("POVERTY RATE");
            d3.select(`label#mapType`).style("display", "block");
            d3.select(`select#mapType`).style("display", "block");
            d3.select(`#mapTypeAll`).style("display", "block");
            d3.select(`#genderAll`).style("display", "none");
            d3.select(`#raceAll`).style("display", "none");
            d3.select(`#edAll`).style("display", "none");
            d3.select(`#hispAll`).style("display", "none");


          }

          //console.log("columnValues.age changed to: ", columnValues.age)

          //update quickfacts

          d3.select("p.quickFacts").html(quickFacts[columnValues.indStat]);

          updateData();
        });


      //load map data and match up state names to codes
      const us = await d3.json("./us.json");
      const code_names = await d3.csv("./state-name-codes.csv", d3.autoType);


      // 3b. Generate the data structures we will need
      var stateDict = {}   // stateID ===> stateData

      code_names.forEach(d => {
        stateDict[d.state_code] = d.state_name;
      });

      var dataDict = {}
      statesData.forEach(d => {
        dataDict[d.state] = { n_estimate: d.n_estimate, p_estimate: d.p_estimate }
      });
      //console.log("dataDict", dataDict);

      //create list of p_estimates to calculate extent
      let all_p_estimates = [];

      for (const key in dataDict) {
        if (dataDict.hasOwnProperty(key) && regions[columnValues.region].includes(key)) {
          const values = dataDict[key];
          all_p_estimates.push(values.p_estimate);
        }
      }

      // console.log("all p est", all_p_estimates);


      //updates text for all disability text for usa (this assumes the first selection is everyone with disability)
      d3.select("span#usa_p_estimate").text(`${dataDict["the United States"].p_estimate}%`);

      var states = topojson.feature(us, us.objects.states);     // List of state outlines to fill
      var statesMesh = topojson.mesh(us, us.objects.states);    // 'Mesh' of all outlines put together for a stroke

      //add names to each state
      states.features.forEach(d => {
        d.name = stateDict[d.id]
      });


      // MAP
      const projection = d3.geoMercator() //geoAlbersUsa() to see alaska
        .scale(1 / (2 * Math.PI))
        .translate([0, 0]);

      let render = d3.geoPath(projection);

      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = svgMap.append("g")
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      let colors = d3.schemeBlues[9];
      let colorScaleState = d3.scaleQuantize(d3.extent(all_p_estimates), colors);

      let statePaths = svgMap.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)  // debugging
        .attr("d", render)
        .attr("fill", d => {
          if (d.name == "Virgin Islands") { return "none" } //we don't have data for Virgin Islands
          else { return colorScaleState(dataDict[d.name].p_estimate) }
        })
        .attr("opacity", 0.8)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState);

      let momesh = svgMap.append("path")
        .attr("class", "mouseover outline")
        .style("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .attr("d", "");

      //Mouseover interaction
      let tooltipWidth = 250;
      let tooltipHeight = 45;

      let tooltip = svgMap.append("g")
        .attr("class", "tooltip")
        .attr("transform", `translate(${20},20)`)
        .attr("visibility", "hidden");

      let box = tooltip.append("rect")
        .attr("fill", "white")
        .attr("opacity", 0.8)
        .attr("x", 0)
        .attr("y", 10)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 15);
      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 35);

      var state_datum = states.features[0]; //use this to store selected SVG element to use for zooming, initialized with first feature

      let selectedValue = "percentage";
     
      function mouseEntersState() {
      
        d3.select("#val").on("change", function() {
          selectedValue =  d3.select(this).property("value");
          console.log(selectedValue)
        });
      
        // Make tooltip visible
        tooltip.style("visibility", "visible")

        let state = d3.select(this);
        state_datum = state.datum();

        let stateID = state_datum.id;

        txt.text(state_datum.name);

        //store text2 so it's easier to adjust length
        let text2 = `${dataDict[state_datum.name].p_estimate}% (${d3.format(",")(dataDict[state_datum.name].n_estimate)})`;
        txt2.text(text2);
    
        let bounds = render.bounds(state.datum());
        let xPos = (state_datum.name === "Alaska") ? bounds[0][0] : (bounds[0][0] + bounds[1][0]) / 2;
        let yPos = bounds[1][1];

        box.attr("width", text2.length * 8.5);
        tooltip
          .attr("transform", `translate(${xPos},${yPos})`)



        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });

        momesh.datum(mo).attr("d", render)

      }

      function mouseLeavesState() {

        // Hide when you leave a state
        tooltip.style("visibility", "hidden");

        let state = d3.select(this);

        // hiding the mouseover mesh
        momesh.attr("d", "");

      }
      var zoom = d3.zoom()
        .scaleExtent([2250, 1 << 20])
        .on("zoom", ({ transform }) => zoomed(transform));


      //centerLocation
      let centerCoordinates = {
        latitude: 41.4925,
        longitude: -79.9018
      };

      svgMap
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(-2250)
          .translate(...projection([centerCoordinates.longitude, centerCoordinates.latitude]))
          .scale(-1)
        )
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);


          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);

        });

        projection
          .scale(transform.k / (2 * Math.PI))
          .translate([transform.x, transform.y]);

        render = d3.geoPath(projection);

        //update state outlines
        statePaths.attr("d", render);

        //update hover path location
        momesh.attr("d", render);

        //update text location
        let bounds = render.bounds(state_datum);
        let xPos = (state_datum.name === "Alaska") ? bounds[0][0] : (bounds[0][0] + bounds[1][0]) / 2;
        let yPos = bounds[1][1];
        tooltip.attr("transform", `translate(${xPos},${yPos})`);

      };

      var filters = {};

      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

        stillPassed = filterFunc(point) && stillPassed;
        return stillPassed;

      }
      
      )}
      

      const ageOptions = {
        0: [
          { value: "0", text: "All Ages" },
          { value: "5", text: "Ages 4 and under" },
          { value: "6", text: "Ages 5-15" },
          { value: "1", text: "Ages 16-20" },
          { value: "2", text: "Ages 21-64" },
          { value: "3", text: "Ages 16-64" },
          { value: "4", text: "Ages 18-64" },
          { value: "7", text: "Ages 65-74" },
          { value: "9", text: "Ages 65+" },
          { value: "8", text: "Ages 75+" }
        ],
        1: [
          { value: "2", text: "Ages 21-64" },
          { value: "1", text: "Ages 16-20" },
          { value: "3", text: "Ages 16-64" },
          { value: "4", text: "Ages 18-64" }
        ],
        2: [
          { value: "2", text: "Ages 21-64" }
        ]
      };

      // Function to update age options
      function updateOptions(data) {
        // Bind data to options
        const options = d3.select("select#age").selectAll("option")
          .data(data)
          .join("option")
          //.classed("custom", true) // Add a class to distinguish custom options
          .attr("value", d => d.value)
          .text(d => d.text);
      }


      //calls update on filters when selections are changed
      function updateMapData(data) {
        console.log(data)
        let statesInFilteredData = new Set(data.map(d => d.state));
        data = data.filter(d => pointPassesFilters(d));
        console.log(data)
        console.log(statesInFilteredData)

        let statesData = datasetsDict[columnValues.indStat].filter(function (row) {
          for (let d of columnsDict[columnValues.indStat]) {
            if (row[d] !== columnValues[d]) {
              //console.log("d: ", d);
              //console.log("row[d]: ", row[d])
              //console.log("columnValues[d]: ", columnValues[d])
              return false; // Exit the loop and filter immediately if a mismatch is found
            }
          }
          return true; // Return true only if all filter conditions are met
        });
        console.log(statesData);

        // Initially update options with sample data
        updateOptions(ageOptions[columnValues.indStat]);
        d3.select(`select#age`)
          .on("change", function () {
            columnValues["age"] = Number(d3.select(this).property("value"));
            console.log(`age changed, logging column values:`, columnValues);

            updateData();
          });

        //console.log("dataDict before", dataDict)
        //refilters the states to be displayed
        statesData.forEach(d => {
          dataDict[d.state] = { n_estimate: d.n_estimate, p_estimate: d.p_estimate }
        });
        //console.log("dataDict after", dataDict)


        /******************* 
        Table Data 
        *******************/
        // plottingPrevalenceTable = columnValues.indStat === 0;
        let goodData;
        if (plottingPrevalenceTable) {
          let dedupedStatesData = statesData.reduce((accumulator, currentLocation) => {
            if (!accumulator.tempLocations.includes(currentLocation.state)) {
              accumulator.tempLocations.push(currentLocation.state); // Add id to tempIds to track uniqueness
              accumulator.unique.push(currentLocation); // Add the current item to the unique list
            }
            return accumulator;
          }, { tempLocations: [], unique: [] }).unique;
          goodData = dedupedStatesData;

        } else {
          goodData = unstackDataset(statesData);
          console.log(goodData);
        }

        // no need to plot rows for things out of region. remove them here
        goodData = goodData.filter(d => {
          return regions[columnValues.region].includes(d.state);
        });


        /******************* 
           End Table Data 
        *******************/

        // reevaluate all p_estimates, should only be states that are in selected region
        all_p_estimates = [];
        for (const key in dataDict) {
          if (dataDict.hasOwnProperty(key) && regions[columnValues.region].includes(key)) {
            const values = dataDict[key];
            all_p_estimates.push(values.p_estimate);
          }
        }

        prevScale = d3.scaleLinear(d3.extent(all_p_estimates), [10, maxBarLength]);
        currentTableData = [...goodData];
        sortedTableData = [...currentTableData];
        updateTableRows(goodData);

        // console.log("usa p est: ", dataDict["the United States"])


        colorScaleState = d3.scaleQuantize(d3.extent(all_p_estimates), colors);

        statePaths.attr("fill", d => {
            console.log(d);
            if (d.name == "Virgin Islands") {
              d.color = "none" //we don't have data for Virgin Islands
            } 
            else if (columnValues.region == 0) {
                if(statesInFilteredData.has(d.name)){
                  d.color = colorScaleState(dataDict[d.name].p_estimate)
                }
                else{
                  d.color = "grey"
                }
            }
            else if (regions[columnValues.region].includes(d.name)){ 
                  if(statesInFilteredData.has(d.name)){
                  d.color = colorScaleState(dataDict[d.name].p_estimate)
                  }
                else{
                  d.color = "grey"
                }
            }
            else{
              d.color = "grey"
            }
            return d.color
            })
            
  
      .attr("stroke", "grey");



        //update subheadings for above map

        d3.select("h4#headingtext").html(headings[columnValues.indStat]);

        //dynamically fill description spans
        columnsDict[columnValues.indStat].forEach(d => {

          let value = key[d][Number(columnValues[d])];
          d3.select(`span#${d}`).text(value);
        })
        d3.select("span#dynamic_p_estimate").text(`${dataDict["the United States"].p_estimate}%`).style("margin-bottom", "2em;");
        
        
    
      }

         // updateMapData();

      
        function makeSlider(sliderdata, container, label, attribute, sliderWidth, sliderHeight) {
      
        
          d3.select("#controlfilter").select("*").remove()
          console.log(sliderdata);
        

          // Get a raw array of values for this property
          let values = statesData.map(d => d[attribute]);
          // console.log(values);

          // Find min and max for some scales
          let minMax = d3.extent(values);
          console.log(minMax);
          let xScale = d3.scaleLinear().domain(minMax)
            .range([10, sliderWidth - 10]); // padding here for ease
          let xAxis = d3.axisBottom(xScale).tickFormat(d3.format(""));


          // Create some HTML elements
          let wrapper = container.append("div").attr("class", "controls");
          wrapper.append("div").text(label);
          let canvas = wrapper.append("svg").attr("width", sliderWidth)
            .attr("height", sliderHeight + 20)
            .attr("attribute", attribute);
          canvas.append("g").attr("transform", `translate(0,${sliderHeight})`)
            .call(xAxis);

          // Make an area chart
          let areaLayer = canvas.append("g");

          // Built-in d3 helper function to count up data
          let numBins = 20;

          // Program a histogram generator to count up data into "bins"
          let histoGen = d3.histogram().domain(minMax)
            .thresholds(numBins);
          let counts = histoGen(values);

          // add dummy object at start of graph
          counts.unshift({
            x0: 0,
            x1: counts[0].x0,
            length: counts[0].length
          });

          let yScale = d3.scaleLinear().domain(d3.extent(counts, d => d.length))
            .range([sliderHeight, 4]);

          // Area generator is like a lineGen, but we give y0 and y1 to fill it in
          let area = d3.area().x(d => xScale(d.x1))
            .y0(yScale(0))
            .y1(d => yScale(d.length))
            .curve(d3.curveNatural);

          // Adding the path works just like a line (the area generator just makes a filled region)
          areaLayer.append("path").datum(counts)
            .attr("class", "area")
            .attr("fill", "#3A7C98")
            .attr("d", area);


          let filterFunc = d => true;
          filters[attribute] = filterFunc;

          var brush = d3.brushX().extent([[10, 0],                           // Upper left corner
          [sliderWidth - 10, sliderHeight]])  // Lower right corner
            .on("brush end", brushMoved);
          // NOTE: we still need to *call the brush* towards the end of our code to "paste" it into HTML

          function brushMoved(event) {

            console.log(event.type, event.selection);

            // Everything but clicking on brush area
            if (event.selection !== null) {

              // Run scales in reverse to get data values for the ends of the brush
              //  If a scale turns data -> pixels, then scale.invert turns pixels -> data
              let start = xScale.invert(event.selection[0]);
              let end = xScale.invert(event.selection[1]);
              let filteredData = sliderdata.filter(d => d[attribute] >= start && d[attribute] <= end);
              console.log(filteredData);

              // Overwrite old filter in our dictionary
              // This filter now only returns True if the point's value is between start and end
              let filterFunc = d => d[attribute] >= start && d[attribute] <= end;
              console.log(filterFunc);
              filters[attribute] = filterFunc;
              console.log(filters[attribute]);

              updateMapData(filteredData)
            }
            // Clicking on brush area to empty it out
            else {
              // Selected nothing, let everything pass
              let filterFunc = d => true;
              filters[attribute] = filterFunc;

              updateMapData(statesData)

            }

          }
          canvas.append("g").attr("class", "brush").call(brush);
        }


        function updateData() {
            updateMapData(statesData);
            let controls = d3.select("#controlfilter");
            let sliderdata;
                  if (columnValues.indStat === 0) {
                    sliderdata = statesData;
                  } else if (columnValues.indStat === 1) {
                    sliderdata = statesData;
                  } else if (columnValues.indStat === 2) {
                    sliderdata = statesData;
                  }


            makeSlider(sliderdata,controls, "Employment Rate (Click + Drag to Filter):", "p_estimate", 700, 60);
          }
  
  
        updateData();
      }

    requestMapData();

    // ---------------
    // HELPER FUNCTIONS
    // ---------------

    //quickfacts for different datasets
    let quickFacts = {
      0: "In 2022, the prevalence of disability was <span class='withColor'>13.4%</span>.",
      1: "In 2022, the national employment rate for people <span class='withHighlight'>with</span> disabilities was <span class='withColor'>45.0%</span> compared to <span class='withoutColor'>81.0%</span> for people <span class='withoutHighlight'>without</span> disabilities, an <span class='gapHighlight'>employment gap</span> of <span class='gapColor'>36.0%</span>.",
      2: "In 2022, the national poverty rate for people <span class='withHighlight'>with</span> disabilities was <span class='withColor'>24.7%</span> compared to <span class='withoutColor'>9.6%</span> for people <span class='withoutHighlight'>without</span> disabilities, a <span class='gapHighlight'>poverty gap</span> of <span class='gapColor'>15.1%</span>."
    }

    //headings for different datasets
    let headings = {
      0: "PREVALENCE: <br>The percentage of non-institutionalized, <span id='gender'>male or female</span>, with <span id='disabilityType'>any</span> disability, <span id='age'>all ages</span>, <span id='race'>all races</span>, <span id='hispanic'>regardless of ethnicity</span>, with <span id='education'>all education levels</span> in the Unites States is <span id='dynamic_p_estimate'>13.9%</span> in 2022.",
      1: "EMPLOYMENT RATE: <br>The employment rate for non-institutionalized,<span id='gender'>male or female</span>, <span id ='MapType'>with</span> <span id='disabilityType'>any</span> disability, <span id='age'>all ages</span>, <span id='race'>all races</span>, <span id='hispanic'>regardless of ethnicity</span>, with <span id='education'>all education levels</span> in the Unites States is <span id='dynamic_p_estimate'>13.9%</span> in 2022.",
      2: "POVERTY RATE: <br>The percentage of non-institutionalized persons ages 21-64 years, <span id ='MapType'>with</span> <span id='disabilityType'>any</span> disability, in the Unites States who were living below the poverty line is <span id='dynamic_p_estimate'>13.9%</span> in 2022."
    }

    //key to match numbers to names, used to dynamically populate descriptions
    let key = {
      
      mapType: {
        0: 'with or without',
        1: 'with',
        2: 'without'
      },
      gender: {
        0: 'male or female',
        1: 'male',
        2: 'female'
      },
      disabilityType: {
        1: 'any',
        2: 'visual',
        3: 'hearing',
        4: 'ambulatory',
        5: 'cognitive',
        6: 'self-care',
        7: 'independent living'
      },
      age: {
        0: 'all ages',
        5: 'ages 4 and under',
        6: 'ages 5-15',
        1: 'ages 16-20',
        2: 'ages 21-64',
        3: 'ages 16-64',
        4: 'ages 18-64',
        7: 'ages 65-74',
        9: 'ages 65+',
        8: 'ages Ages 75+'
      },
      race: {
        0: 'all races',
        1: 'White',
        2: 'Black/African American',
        3: 'Native American or Alaska native',
        4: 'Asian',
        5: 'some other race(s)'
      },
      education: {
        0: 'all education levels',
        1: 'less than a high school education',
        2: 'a high school diploma or equivalent',
        3: 'some college/associates degree',
        4: 'a BA degree or higher'
      },
      hispanic: {
        0: 'regardless of ethnicity',
        1: 'Hispanic',
        2: 'non-Hispanic'
      },
    }



  </script>


  <!--  ==================
          TABLE SCRIPT
        ================== -->
  <script>

    //--- We are going to make the table
    // Create the <svg> where it lives or select it
    // Make the extra g tags for annotations and lines and labels etc
    // Call updateTableRows on your data array to fill in each row

    // --- Someone pressed a sorting button
    // Re-sort the data array based on some criteria
    //  (e.g. now the lowest p_est is first instead of alphabetical by state)
    // Call updateTableRows again on the newly sorted dataset

    // -- Someone changed ANYTHING else in the filter panel etc
    // Just make sure that your data array has the right stuff in it
    // Then call updateTableRows
    const empSVG = d3.select("svg#prevalenceTable");
    const empSVGWidth = empSVG.attr("width");
    var currentEmpSVGHeight = empSVG.attr("height");
    const empSVGMargin = { top: 40, right: 30, bottom: 50, left: 130 };
    const empChartWidth = empSVGWidth - empSVGMargin.left - empSVGMargin.right;

    const rowHeight = 30;

    const maxBarLength = 250;
    var currentTableData;
    let sortedTableData;

    var subchartStartPos;
    const subchartMargin = 7;

    const tableCategories = ["Location", "Estimate (%)", "90% MOEp", "Estimate (number)", "90% MOEn", "Base Population", "Sample Size"];
    const tableGroups = ["Location", "Percent", "Number", "Base Population", "Sample Size"];

    const groupToCategories = {
      "Location": ["Location"],
      "Percent": ["Estimate (%)", "90% MOEp"],
      "Number": ["Estimate (number)", "90% MOEn"],
      "Base Population": ["Base Population"],
      "Sample Size": ["Sample Size"]
    }

    let activeTableGroups = [...tableGroups];
    let activeTableCategories = [...tableCategories];

    const locationStart = 0;
    const locationWidth = 175;

    const pEstimateStart = locationStart + locationWidth;
    const pEstimateWidth = 80;

    const pMoeStart = pEstimateStart + pEstimateWidth;
    const pMoeWidth = 80;

    const nEstimateStart = pMoeStart + pMoeWidth;
    const nEstimateWidth = 100;

    const nMoeStart = nEstimateStart + nEstimateWidth;
    const nMoeWidth = 80;

    const populationStart = nMoeStart + nMoeWidth;
    const populationWidth = 120;

    const sampleStart = populationStart + populationWidth;
    const sampleWidth = 90;

    const thousandFormatter = d3.format(",");
    const floatFormatter = d3.format(".1f");

    function customFormatter(value) {
      const formattedVal = d3.format(",")(value);
      return `±${formattedVal}`;
    }

    const barMargin = 5;
    const endCircleRadius = 10;

    const mouseOverLabelBoxHeight = 20;
    const mouseOverLabelBoxWidth = 75;

    const headerHeight = 50;
    const tableFontSize = 12;
    const textMargin = 10;

    const closeHeight = 30;
    const closeWidth = 40;
    const closeInnerBoxHeight = 20;
    const xMargin = 3;

    const subLegendLeftAdjustment = 50;
    const subLegendYMargin = 15;

    const subLegendTextMargin = 15;

    const categorySpacing = 10;


    const tableSpacingDict = {};

    var currentShownBars = ["withBox", "withoutBox", "gapBox"];

    // syntax for this dict, value 0 is start pos, value 1 is width, value 2 is header name, value 3 is formatter for displaying the value
    tableSpacingDict[tableCategories[0]] = [locationStart, locationWidth, "state", null];
    tableSpacingDict[tableCategories[1]] = [pEstimateStart, pEstimateWidth, "p_estimate", null];
    tableSpacingDict[tableCategories[2]] = [pMoeStart, pMoeWidth, "p_estimate_moe", customFormatter];
    tableSpacingDict[tableCategories[3]] = [nEstimateStart, nEstimateWidth, "n_estimate", thousandFormatter];
    tableSpacingDict[tableCategories[4]] = [nMoeStart, nMoeWidth, "n_estimate_moe", customFormatter];
    tableSpacingDict[tableCategories[5]] = [populationStart, populationWidth, "base_population", thousandFormatter];
    tableSpacingDict[tableCategories[6]] = [sampleStart, sampleWidth, "sample_size", thousandFormatter];

    const tableGroupPositions = {}

    tableGroupPositions[tableGroups[0]] = [locationStart, locationWidth];
    tableGroupPositions[tableGroups[1]] = [d3.min([pEstimateStart, pMoeStart]), pEstimateWidth + pMoeWidth];
    tableGroupPositions[tableGroups[2]] = [d3.min([nEstimateStart, nMoeStart]), nEstimateWidth + nMoeWidth];
    tableGroupPositions[tableGroups[3]] = [populationStart, populationWidth];
    tableGroupPositions[tableGroups[4]] = [sampleStart, sampleWidth];

    // console.log(tableSpacingDict["Location"][3] != null);

    const percentScale = d3.scaleLinear()
      //.domain(empExtent)
      .domain([0, 100]) // for 0-100% scale vs. empExtent
      .range([0, maxBarLength]);


    var prevScale;

    var tableSortingState = {
      category: null,
      direction: null,
      active: false
    }

    // console.log(empChartWidth - (sampleStart + sampleWidth));





    // temp
    let drawWith = true;
    let drawWithout = true;
    let drawGap = true;
    // const loadEmpData = async function () {

    //   // ======        
    //   //  DATA
    //   // ======
    //   let empData = await d3.csv("acs_emp03.csv", d3.autoType)
    //   let goodData = unstackDataset(empData);
    //   console.log(goodData);

    //   let allWithout = d3.map(goodData, d => {
    //     return d["without"];
    //   })



    //   updateTableRows(goodData);
    // }

    function unstackDataset(stackedCSV) {
      // takes in the 104 stacked rows from the CSV 
      // returns 52 unstacked rows that have both "with" and "without" keys 
      //  for the matching p_estimates
      // RUN THIS FIRST TO MAKE A GOOD DATASET, THEN SORT AND EVERYTHING ELSE!

      let new_dataset = {};

      stackedCSV.forEach(d => {
        // check which kind of data it is
        let label = ""
        if (d.disabilityType === 1) {
          label = "with";
        }
        else if (d.disabilityType === 2) {
          label = "without";
        }
        else {
          label = "NULL";
        }

        let state = d.state;
        if (state in new_dataset) {
          // update the row with the new value
          new_dataset[state][label] = d.p_estimate;
        }
        else
          new_dataset[state] = {
            "state": d.state,
            "sample_size": d.sample_size,
            "base_population": d.base_population,
            "n_estimate": d.n_estimate,
            "n_estimate_moe": d.n_estimate_moe,
            "p_estimate": d.p_estimate,
            "p_estimate_moe": d.p_estimate_moe,
            "id": d.id
          }

        console.log(state, new_dataset[state], new_dataset);
        new_dataset[state][label] = d.p_estimate;

      });

      // we need to convert from a dictionary back into a simple array
      return Object.values(new_dataset);

    }



    function updateTableRows(sorted_dataset) {
      recalculateTablePositions();
      subchartStartPos = calculateSubchartStartPosition();

      // get the height of the svg
      var requiredHeight = (sorted_dataset.length * rowHeight) + headerHeight + closeHeight + empSVGMargin.bottom;
      empSVG.attr("height", requiredHeight);
      currentEmpSVGHeight = empSVG.attr("height");


      empSVG.selectAll("g.tHeader").remove();
      addHeader(empSVG);

      empSVG.selectAll('g.row').remove();

      empSVG.selectAll('g.row')
        .data(sorted_dataset, d => d["state"])
        .join(enter => {
          let rows = enter.append("g").attr("class", "row");
          rows.attr("transform", (d, i) => `translate(0, ${empSVGMargin.top + headerHeight + i * rowHeight})`);

          // TODO add and configure the text part including their x position
          //   y position should always take into account the translate above
          rows.append("line")
            .attr("class", "tableSeperator")
            .attr("x1", 0)
            .attr("x2", subchartStartPos + maxBarLength)
            .attr("y1", 0)
            .attr("y2", 0)

          activeTableCategories.forEach(cat => {

            rows.append("text")
              .attr("class", `tableText ${cat}`)
              .text(d => {
                let displayText;
                if (d[tableSpacingDict[cat][2]] == "the United States") {
                  displayText = "United States";
                } else {
                  displayText = d[tableSpacingDict[cat][2]];
                }
                if (displayText == "-9") {
                  displayText = "0";
                }

                //uses formatter specified in table dict (poorly named ik) if it exists
                if (tableSpacingDict[cat][3] != null) {
                  return tableSpacingDict[cat][3](displayText);
                }
                return displayText;
              })
              .attr("x", d => {
                if (cat == tableCategories[0]) {
                  return tableSpacingDict[cat][0] + textMargin;
                }
                return tableSpacingDict[cat][0] + tableSpacingDict[cat][1] - textMargin - categorySpacing;
              })
              .attr("y", rowHeight / 2);
          });


          let subcharts = rows.append("g")
            .attr("class", "empSVG")
            .attr("transform", `translate(${subchartStartPos - subchartMargin}, 0)`)
          // shift the chart over a bit so its on right side


          subcharts.each(updateEmpSvg)

        },
          update => {
            update.transition() // animate them shuffling around???
              .attr("transform", (d, i) => `translate(0, ${i * rowHeight})`);

            // select and update each of the text elements as necessary
            //  (this is why it's important to add classes in enter)
            update.select("text.p_estimate")
              .text(d => d['p_estimate']);
            // ... append other text inside of the rows

            // select and update the fancy sub-chart
            //  (this is why it's important to add classes in enter)
            let subcharts = update.selectAll("g.empSVG")

            // but how do we get each of the charts to have the right contents?
            //  ... and, how do we make sure they update properly
            subcharts.each(updateEmpSvg)

          },
          exit => {
            exit.transition()
              .attr("opacity", 0)
              .remove()
          });
    }

    function updateEmpSvg(d, i) {
      // expects to get one point of data from your array
      // e.g. d={'with_est':,'without_est':}

      // console.log("updateEmpSvg", i, d);

      let empSVG = d3.select(this);
      if (i == 0) {
        let subLegendG = empSVG.append("g")
          .attr("class", "subchartLegend")
          .attr("transform", `translate(${subLegendLeftAdjustment}, ${-headerHeight - closeHeight - (barMargin)})`);

        let legendLine = subLegendG.append("line")
          .attr("class", "subchartLegend")
          .attr("x1", 0)
          .attr("x2", 0)
          .attr("y2", headerHeight + closeHeight)
          .attr("stroke-width", 1)
          .attr("stroke", "black");

        let firstBar = subLegendG.append("rect")
          .attr("class", "withBarHeader")
          .attr("x", .5)
          .attr("width", percentScale(10))
          .attr("height", rowHeight - 2 * barMargin);

        let firstBarCircle = subLegendG.append("circle")
          .attr("class", "withEndCircleHeader")
          .attr("cx", percentScale(10))

          .attr("r", endCircleRadius);

        let firstBarText = subLegendG.append("text")
          .attr("x", percentScale(10) + subLegendTextMargin)
          .attr("class", "headerLegendText");



        let secondBar = subLegendG.append("rect")
          .attr("class", "withoutBarHeader")
          .attr("x", .5)
          .attr("width", percentScale(25))
          .attr("height", rowHeight - 2 * barMargin);

        let secondBarCircle = subLegendG.append("circle")
          .attr("cx", percentScale(25))
          .attr("r", endCircleRadius);


        let secondBarText = subLegendG.append("text")
          .attr("x", percentScale(25) + subLegendTextMargin)
          .attr("class", "headerLegendText");

        if (plottingPrevalenceTable) {
          // This commented code is if we have the ability to drop down for specific disability info
          // legendLine
          //   .attr("y1", rowHeight - barMargin);
          // firstBar
          //   .attr("y", rowHeight);
          // firstBarCircle
          //   .attr("cy", 1.5 * rowHeight - barMargin);

          // firstBarText
          //   .attr("y", 1.5 * rowHeight - barMargin)
          //   .text("any disability");

          // secondBar
          //   .attr("y", rowHeight * 2 - barMargin)
          // secondBarCircle
          //   .attr("cy", rowHeight * 2.5 - 2 * barMargin)
          //   .attr("fill", "#00368C");
          // secondBarText
          //   .attr("y", rowHeight * 2.5 - 2 * barMargin)
          //   .text("specific disabilities");
          legendLine
            .attr("y1", rowHeight * 1.5);
          firstBar
            .attr("y", 1.5 * rowHeight + barMargin);
          firstBarCircle
            .attr("cy", 1.5 * rowHeight + barMargin + endCircleRadius);

          firstBarText
            .attr("y", 1.5 * rowHeight + barMargin + endCircleRadius)
            .text("any disability");

          secondBar.remove();
          secondBarCircle.remove();
          secondBarText.remove();
        } else {
          legendLine
            .attr("y1", 0);

          //first bar
          firstBar
            .attr("x", .5)
            .attr("y", barMargin);
          firstBarCircle
            .attr("cy", rowHeight / 2);

          firstBarText
            .attr("y", rowHeight / 2)
            .text("with disability");
          //2nd bar
          secondBar
            .attr("y", rowHeight);

          secondBarCircle
            .attr("cy", 2 * barMargin + rowHeight);
          secondBarText
            .attr("y", rowHeight + (rowHeight / 2) - barMargin)
            .text("without disability")


          //not  prev so have gaps
          subLegendG.append("rect")
            .attr("class", "gapBarHeader")
            .attr("x", percentScale(10))
            .attr("width", percentScale(15))
            .attr("y", (rowHeight * 2) - barMargin)
            .attr("height", rowHeight - 2 * barMargin);

          subLegendG.append("circle")
            .attr("class", "gapCirclesHeader")
            .attr("cx", percentScale(10))
            .attr("cy", rowHeight * 2 + barMargin)
            .attr("r", endCircleRadius);
          subLegendG.append("circle")
            .attr("class", "gapCirclesHeader")
            .attr("cx", percentScale(25))
            .attr("cy", rowHeight * 2 + barMargin)
            .attr("r", endCircleRadius);

          subLegendG.append("text")
            .attr("class", "headerLegendText")
            .attr("x", percentScale(25) + subLegendTextMargin)
            .attr("y", 2 * rowHeight + (rowHeight / 2) - 2 * barMargin)
            .text("employment gap");

          secondBarCircle.attr("fill", "#59A4EF");

          let checkBoxes = d3.selectAll("input.legendBox").each((d, i, nodes) => {
            // let currentBox = d3.select(this);
            // console.log(currentBox.node());
            // checkBox.attr("x",)
            let currentBox = d3.select(nodes[i]);

            currentBox
              .style("left", subchartStartPos + subLegendLeftAdjustment / 2)
              .style("top", 6.5 +
                i * (rowHeight - barMargin))
              .style("visibility", "visible")
              .property("checked", true)
              .on("change", toggleBar);

          });

        }
      }

      if (drawWithout && !plottingPrevalenceTable) {
        let lightBlueLine = empSVG.selectAll("rect.withoutBar")
          .data([d])
          .join( // make new bar without animation
            enter => enter.append("rect")
              .attr("class", "withoutBar")
              .attr("x", 0)
              .attr("y", barMargin)
              .attr("width", d => percentScale(d.without))
              .attr("height", rowHeight - 2 * barMargin)
              .on("mouseover", d => { })
            ,
            // update bar with moving line animations
            // for animation, add .call
            update => update.call(update =>
              update.transition()
                .attr("width", d => percentScale(d.without))
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            });
      }

      if (drawWith) {
        let darkBlueLine = empSVG.selectAll("rect.withBar")
          .data([d])
          .join( // make new bar without animation
            enter => enter.append("rect")
              .attr("class", "withBar")
              .attr("x", 0)
              .attr("y", barMargin)
              .attr("width", d => {
                if (plottingPrevalenceTable) {
                  return prevScale(d.p_estimate);
                }
                return percentScale(d.with);
              })
              .attr("height", rowHeight - 2 * barMargin)
              .on("mouseover", d => { })
            ,
            // update bar with moving line animations
            // for animation, add .call
            update => update.call(update =>
              update.transition()
                .attr("width", d => {
                  if (plottingPrevalenceTable) {
                    return prevScale(d.p_estimate);
                  }
                  return percentScale(d.with);
                })
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            });
        let darkBlueCircle = empSVG.selectAll("circle.withEndCircle")
          .data([d])
          .join(
            enter => enter.append("circle")
              .attr("class", "withEndCircle")
              .attr("cx", d => {
                if (plottingPrevalenceTable) {
                  return prevScale(d.p_estimate);
                }
                return percentScale(d.with);
              })
              .attr("cy", rowHeight / 2)
              .attr("r", endCircleRadius)
              .attr("rowIndex", i)
              .on("mouseover", circleHover)
              .on("mouseleave", circleUnhover)
            ,

            update => update.call(update =>
              update.transition()
                .attr("cx", d => {
                  if (plottingPrevalenceTable) {
                    return prevScale(d.p_estimate);
                  }
                  return percentScale(d.with);
                })
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            })
      }


      if (drawWithout && !plottingPrevalenceTable) {
        let lightBlueCircle = empSVG.selectAll("circle.withoutEndCircle")
          .data([d])
          .join(
            enter => enter.append("circle")
              .attr("class", "withoutEndCircle")
              .attr("cx", d => percentScale(d.without))
              .attr("cy", rowHeight / 2)
              .attr("r", endCircleRadius)
              .attr("rowIndex", i)
              .on("mouseover", circleHover)
              .on("mouseleave", circleUnhover)
            ,

            update => update.call(update =>
              update.transition()
                .attr("cx", d => percentScale(d.without))
            ),
            exit => {
              exit.transition()
                .attr("opacity", 0)
                .remove()
            })

      }
      if (drawGap && !plottingPrevalenceTable) {

        let gapText = empSVG.selectAll("text.gapText")
          .data([d])
          .join(
            enter => enter.append("text")
              .attr("class", "tableText gapText")
              .attr("x", empChartWidth - (sampleStart + sampleWidth))
              .attr("y", rowHeight / 2)
              .text(d => floatFormatter(d.without - d.with) + "%")
          );
      }

    }

    function circleHover(event, d) {
      // console.log(event, d);
      let circle = d3.select(this)
        .attr("r", endCircleRadius * 1)
        .style("fill", "white")
        .attr("stroke", "black")
        .attr("stroke-width", "8px");



      let xPos = Number(circle.attr("cx")) + subchartStartPos;
      let yPos = Number(circle.attr("cy")) + headerHeight + rowHeight * circle.attr("rowIndex");

      let g = empSVG.append("g")
        .attr("transform", `translate(${xPos - mouseOverLabelBoxWidth / 2}, ${yPos})`)
        .attr("class", "mouseOverLabel")
        .style("pointer-events", "none")
      g.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", mouseOverLabelBoxWidth)
        .attr("height", mouseOverLabelBoxHeight)
        .attr("fill", "white")
        .attr("stroke", "black")

      let estimateToShow = d.p_estimate;
      let displayNA = false;
      if (Number(estimateToShow) == -9) {
        displayNA = true;
      }

      g.append("text")
        .attr("x", mouseOverLabelBoxWidth / 2)
        .attr("y", mouseOverLabelBoxHeight / 2)
        .attr("font-size", tableFontSize + "px")
        .attr("dominant-baseline", "middle")
        .attr("text-anchor", "middle")
        .text(() => {
          if (displayNA) {
            return "No Data";
          }
          return "Rate: " + d.p_estimate + "%"
        })
    }

    function circleUnhover(event, d) {
      d3.select(this)
        .attr("r", endCircleRadius)
        .style("fill", "")
        .attr("stroke", "none")
        .attr("stroke-width", "0px");

      empSVG.select(".mouseOverLabel").remove() // find the thing with the class and remove it
    }

    function addHeader(target) {
      var headerGroup = target.append("g")
        .attr("class", "tHeader")
        .attr("transform", `translate(${0}, ${empSVGMargin.top})`);

      activeTableGroups.forEach(group => {
        //add group seperators

        headerGroup.append("line")
          .attr("class", "groupLines")
          .attr("x1", tableGroupPositions[group][0] + tableGroupPositions[group][1] + categorySpacing / 4)
          .attr("x2", tableGroupPositions[group][0] + tableGroupPositions[group][1] + categorySpacing / 4)
          .attr("y1", headerHeight)
          .attr("y2", currentEmpSVGHeight - rowHeight - empSVGMargin.bottom)
          .attr("stroke-width", 1)
          .attr("stroke", "black")
          .raise();

        headerGroup.append("rect")
          .attr("class", `tableHeaderBox ${group}`)
          .attr("x", tableGroupPositions[group][0] - categorySpacing / 2)
          .attr("width", tableGroupPositions[group][1] + categorySpacing / 2)
          .attr("height", headerHeight);



        var closeButtonGroup = headerGroup.append("g").attr("class", `closeGroup ${group}`).datum(group);
        if (group != tableGroups[0]) {
          let closeProtrusion = closeButtonGroup.append("rect")
            .attr("class", `tableHeaderBox closeProtrusion ${group}`)
            .attr("x", tableGroupPositions[group][0] + tableGroupPositions[group][1] - closeWidth)
            .attr("y", -closeHeight)
            .attr("width", closeWidth)
            .attr("height", closeHeight)
            .on("click", closeGroup);


          let closeSquare = closeButtonGroup.append("rect")
            .attr("class", `closeSquare`)
            .attr("x", Number(closeProtrusion.attr("x")) + (closeWidth) / 4)
            .attr("y", -closeInnerBoxHeight)
            .attr("width", closeWidth / 2)
            .attr("height", closeInnerBoxHeight)
            .on("click", closeGroup);

          closeButtonGroup.append("line")
            .attr("class", `closeX`)
            .attr("x1", Number(closeSquare.attr("x")) + xMargin)
            .attr("x2", Number(closeSquare.attr("x")) + (closeWidth / 2) - xMargin)
            .attr("y1", -closeInnerBoxHeight + xMargin)
            .attr("y2", - xMargin)
            .attr("stroke", "black")
            .on("click", closeGroup);


          closeButtonGroup.append("line")
            .attr("class", `closeX`)
            .attr("x2", Number(closeSquare.attr("x")) + xMargin)
            .attr("x1", Number(closeSquare.attr("x")) + (closeWidth / 2) - xMargin)
            .attr("y1", -closeInnerBoxHeight + xMargin)
            .attr("y2", -xMargin)
            .attr("stroke", "black")
            .on("click", closeGroup);

        } else {
          //aka this is location
          closeButtonGroup.append("text")
            .attr("class", "resetText")
            .attr("x", 0)
            .attr("y", -closeHeight + (tableFontSize))
            .text("RESET TABLE")
            .on("click", resetTable);
        }

      });

      activeTableCategories.forEach(cat => {
        const headerText = headerGroup.append("text")
          .attr("class", `tHeaderText tableText ${cat}`)
          .attr("x", tableSpacingDict[cat][0] + (textMargin))
          .attr("y", (rowHeight / 2) - (1.5 * tableFontSize));


        const words = cat.split(" ");
        if (words.length > 1) {
          words.forEach((word, index) => {
            headerText.append("tspan")
              .attr("x", tableSpacingDict[cat][0] + (tableSpacingDict[cat][1]) - textMargin - categorySpacing)
              .text(word)
              .attr("dy", 1.5 * tableFontSize)
          });
        } else {
          headerText.text(cat).attr("y", (rowHeight / 2) + 18);
        }

        const downTrianglePoints = [[-5, 0], [5, 0], [0, 10]]
        const upTrianglePoints = [[-5, 0], [5, 0], [0, -10]];
        // let areaLabelTriangle = areaLabel.append("polygon")
        //   .attr("points", trianglePoints.map(point => point.join(",")).join(" "))
        //   .style("fill", "orangered")
        // make sorters
        activeTableCategories.forEach(cat => {

          if (cat != tableCategories[0]) {
            let filterGroup = headerGroup.append("g");

            let downTriangle = filterGroup.append("polygon")
              .attr("class", `triangle${cat} tableFilterButton`)
              .attr("id", "down")
              .attr("category", `${cat}`)
              .attr("points", downTrianglePoints.map(point => point.join(",")).join(" "))
              .attr("transform", `translate(${tableSpacingDict[cat][0] + tableSpacingDict[cat][1] - categorySpacing / 1.5}, ${headerHeight / 2})`)
              .attr("state", () => {
                if (tableSortingState.active && tableSortingState.category === cat && tableSortingState.direction === "down") {
                  return "active";
                }
                return "inactive";
              })
              .attr("fill", () => {
                if (tableSortingState.active && tableSortingState.category === cat && tableSortingState.direction === "down") {
                  return "#3573D9";
                }
                return "#8BAEE8";
              })
              .on("click", sortTable);
            let upTriangle = filterGroup.append("polygon")
              .attr("class", `triangle${cat} tableFilterButton`)
              .attr("id", "up")
              .attr("category", `${cat}`)
              .attr("points", upTrianglePoints.map(point => point.join(",")).join(" "))
              .attr("transform", `translate(${tableSpacingDict[cat][0] + tableSpacingDict[cat][1] - categorySpacing / 1.5}, ${headerHeight / 2 - 5})`)
              .attr("state", () => {
                if (tableSortingState.active && tableSortingState.category === cat && tableSortingState.direction === "up") {
                  return "active";
                }
                return "inactive";
              })
              .attr("fill", () => {
                if (tableSortingState.active && tableSortingState.category === cat && tableSortingState.direction === "up") {
                  return "#3573D9";
                }
                return "#8BAEE8";
              })
              .on("click", sortTable);
          }
        });

      });

      return headerGroup;
    }
    function closeGroup(event, d) {
      if (activeTableGroups.includes(d)) {
        activeTableGroups.splice(activeTableGroups.indexOf(d), 1);
      }
      let catsToRemove = groupToCategories[d];
      catsToRemove.forEach(c => {
        if (activeTableCategories.includes(c)) {
          activeTableCategories.splice(activeTableCategories.indexOf(c), 1);
        }
      });

      updateTableRows(sortedTableData);
    }

    function resetTable(event, d) {
      console.log("Active before reset stuff", activeTableGroups, activeTableCategories);
      activeTableCategories = [...tableCategories];
      activeTableGroups = [...tableGroups];
      tableSortingState = {
        category: null,
        direction: null,
        active: false
      }
      updateTableRows(currentTableData);

      console.log("Active stuff now", activeTableGroups, activeTableCategories);
    }

    function recalculateTablePositions() {
      let currentPosition = 0;

      tableGroups.forEach(group => {
        if (activeTableGroups.includes(group)) {
          // Reset groupWidth for each group
          let groupWidth = 0;
          const categories = groupToCategories[group];

          categories.forEach((cat, index) => {
            if (activeTableCategories.includes(cat)) {
              // Start positions for each category now consider the spacing
              tableSpacingDict[cat][0] = currentPosition;
              currentPosition += tableSpacingDict[cat][1]; // Move by the width of the category

              // Add spacing after each category except the last one in the group
              if (index < categories.length - 1) {
                currentPosition += categorySpacing;
              }

              // Accumulate groupWidth including spacing between categories
              groupWidth += tableSpacingDict[cat][1] + (index < categories.length - 1 ? categorySpacing : 0);
            }
          });

          // Update group position and width
          tableGroupPositions[group] = [currentPosition - groupWidth, groupWidth];
          // If you want space after each group, add it to currentPosition here
          currentPosition += categorySpacing; // Optional: add space after each group
        }
      });
    }

    function calculateSubchartStartPosition() {
      // Assuming lastGroupEdge calculation remains the same
      let lastGroupEdge = 0;
      activeTableGroups.forEach(group => {
        const groupPosition = tableGroupPositions[group];
        if (groupPosition) {
          const groupEdge = groupPosition[0] + groupPosition[1];
          lastGroupEdge = Math.max(lastGroupEdge, groupEdge);
        }
      });

      // Include additional spacing if required before starting subcharts
      return lastGroupEdge + categorySpacing; // Add spacing before subcharts start
    }

    function toggleBar(event, d) {
      let barToChange = event.target.id;
      if (event.target.checked) {
        currentShownBars.push(barToChange);
      } else {
        if (currentShownBars.includes(barToChange)) {
          currentShownBars.splice(currentShownBars.indexOf(barToChange), 1);
        }
      }

      // console.log(currentShownBars);
    }

    function sortTable(event) {
      let dataToSort = [...currentTableData];
      let ascending = false;
      let clickedButton = d3.select(this);
      let property = tableSpacingDict[clickedButton.attr("category")][2];
      let nowSorting = null;

      // Reset all triangles to inactive state except for the clicked one
      d3.selectAll(".tableFilterButton")
        .each(function () {
          if (d3.select(this).attr("id") !== clickedButton.attr("id") || d3.select(this).attr("category") !== clickedButton.attr("category")) {
            d3.select(this).attr("fill", "#8BAEE8").attr("state", "inactive");
          }
        });

      let isActive = clickedButton.attr("state") === "active";
      if (isActive) {
        clickedButton.attr("fill", "#8BAEE8").attr("state", "inactive");

        //unsort table??
        nowSorting = false;

      } else {
        clickedButton.attr("fill", "#3573D9").attr("state", "active");

        ascending = clickedButton.attr("id") === "up";


        dataToSort.sort((a, b) => ascending ? a[property] - b[property] : b[property] - a[property]);
        nowSorting = true;

        // Log the sorted data or update your table with it
        console.log(dataToSort);
      }

      tableSortingState = {
        category: clickedButton.attr("category"),
        direction: ascending ? "up" : "down",
        active: nowSorting
      }

      sortedTableData = [...dataToSort];

      updateTableRows(sortedTableData);

    }
  
    // loadEmpData();


  </script>

</body>