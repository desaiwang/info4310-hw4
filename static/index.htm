<html>

<head>
  <title>INFO 4310 - HW4</title>
  <!-- <link href="./style.css" rel="stylesheet" type="text/css"> -->

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">


  <style>
    body {
      font-family: 'Barlow', 'Helvetica', sans-serif;
      font-weight: 400;
      margin: 0 0 0 100px;
      padding: 0;
      min-width: 1400px;
      /* overflow-x: scroll;
      overflow-y: hidden;
      overscroll-behavior-x: none; */
    }

    h1 {
      font-weight: 600;
      font-size: 3em;
      margin: 20px 0 0 0;
      padding: 0;
      color: black;
    }

    h2 {
      font-weight: 700;
      font-size: 2em;
      margin: 0;
      padding: 0 0 5px 0;
      color: #3A7C98;
      /* border-bottom: 1px solid #777; */
    }

    h3 {
      font-weight: 700;
      font-size: 1.05em;
      margin: 0;
      padding: 0px 0 15px 0;
      color: #3A7C98;
    }

    h3.withRule {
      border-top: 1px solid #ccc;
      padding-top: 12px;
      margin-top: 15px;
    }

    h3#best {
      font-weight: 800;
      font-size: 1.15em;
      color: #d81289;
    }

    p {
      margin: 0;
      padding: 3px 0;
      line-height: 1.3em;
    }

    p#tagline {
      font-size: 1.1em;
      color: #3A7C98;
      margin: 0;
      padding: 0 0 35 0;
    }

    /* BUTTONS */
    button {
      font-family: 'Barlow', 'Helvetica', sans-serif;
      background-color: #ffffff;
      border: 2px solid #777;
      color: #777;
      border-radius: 20px;
      margin: 0 7px 10px 0;
      padding: 6px 10px 8px 10px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
    }

    /* button[value="cafes"]::before {
      content: "#";
      color: gray;
    }
    .clicked[value="cafes"]::before {
      content: url("logo.png");
      content: "#";
      color: purple;
    }     */

    .clicked {
      background-color: #e3d2fd;
      border: 2px solid #7339D0;
      color: #7339D0;
    }

    button:hover {
      text-decoration: underline dotted;
      text-underline-offset: 3px;
    }

    .clicked:hover {
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    #distance button {
      width: 80px;
    }

    #category button {
      width: 125px;
    }

    #category {
      display: flex;
      flex-direction: column;
    }

    #category select {
      width: 200px;
      height: 2em;
    }

    #category label {
      margin-top: .5em;
      margin-bottom: 0.1em;
    }

    button#selectAllButton,
    button#resetButton {
      margin: 0 0 12px 0;
      padding: 0;
      border: 0;
      font-size: .95em;
      font-weight: 500;
      color: #3A7C98;
    }

    #selectAllButton:hover,
    #resetButton:hover {
      background-color: white;
      border: 0;
      border-radius: 0;
      text-decoration: underline dotted;
      text-underline-offset: 3px;
    }

    /* CONTAINERS */
    .flex-container {
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      flex-wrap: nowrap;
    }

    div.filterColumn {
      margin: 0;
      padding: 10px 35px 10px 0;
      min-width: 300px;
      max-width: 300px;
    }


    div.mapColumn {
      margin: 0;
      padding: 10px 35px 10px 0;
    }

    div.filterButtonContainer {
      height: calc(100vh - 170px);
      /* overflow-y: scroll; */
    }

    div.restaurant-list-info {
      max-width: 400px;
      min-width: 300px;
      margin: 0;
      padding: 145px 20px 0 0;
    }

    .restaurant-list {
      height: calc(100vh - 240px);
      margin: 0;
      padding: 5px 35px 10px 10px;
      overflow-y: scroll;
    }

    .restaurant-list a {
      text-decoration: none !important;
      color: inherit;
    }

    .restaurant-item {
      margin-bottom: 10px;
    }

    div.mapColumn {
      overflow-x: scroll;
      overflow-y: hidden;
    }

    .tick line {
      visibility: hidden;
    }

    .tick text {
      font-size: 16px
    }

    .domain {
      visibility: hidden;

    }
  </style>

</head>

<body>
  <div>
    <h2>EMPLOYMENT RATE</h2>
    <h1 style="margin-bottom: 1.25em;">In 2022, the employment rate for the disabled population in the United States is
      <span id=usa_p_estimate style="color: #3A7C98">13.9%</span>.
    </h1>
  </div>

  <div class="flex-container">

    <!--  ---------------
              FILTERS 
          --------------- -->
    <div class="filterColumn">
      <h10>FILTERS</h10>

      <div class="filterButtonContainer">
        <!-- CATEGORY FILTER-->
        <h3 class="withRule">POPULATION CHARACTERISTICS</h3>
        <button id="selectAllButton" value="selectAll">SELECT ALL</button>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<button
          id="resetButton" value="reset">CLEAR ALL</button>
        <div id="category">
          <label for="mapType">Map Type:</label>
          <select id="mapType" name="mapType">
            <option value="0" selected>With or Without Disability</option>
            <option value="1">With Disability</option>
            <option value="2">Without Disability</option>
          </select>

          <label for="gender">Gender:</label>
          <select id="gender" name="gender">
            <option value="0" selected>Male or Female</option>
            <option value="1">Males</option>
            <option value="2">Females</option>
          </select>

          <label for="disabilityType">Disability Type:</label>
          <select id="disabilityType" name="disabilityType">
            <option value="1" selected>Any Disability</option>
            <option value="2">Visual Disability</option>
            <option value="3">Hearing Disability</option>
            <option value="4">Ambulatory Disability</option>
            <option value="5">Cognitive Disability</option>
            <option value="6">Self-Care Disability</option>
            <option value="7">Independent Living Disability</option>
          </select>

          <label for="age">Age:</label>
          <select id="age" name="age">
            <option value="0" selected>All Ages</option>
            <option value="5">Ages 4 and under</option>
            <option value="6">Ages 5-15</option>
            <option value="1">Ages 16-20</option>
            <option value="2">Ages 21-64</option>
            <option value="3">Ages 16-64</option>
            <option value="4">Ages 18-64</option>
            <option value="7">Ages 65-74</option>
            <option value="9">Ages 65+</option>
            <option value="8">Ages 75+</option>
          </select>

          <label for="race">Race:</label>
          <select id="race" name="race">
            <option value="0" selected>All races</option>
            <option value="1">White</option>
            <option value="2">Black/African American</option>
            <option value="3">Native American or Alaska Native</option>
            <option value="4">Asian</option>
            <option value="5">Some other race(s)</option>
          </select>

          <label for="education">Education:</label>
          <select id="education" name="education">
            <option value="0" selected>All education levels</option>
            <option value="1">Less than a high school education</option>
            <option value="2">A high school diploma or equivalent</option>
            <option value="3">Some college/associates degree</option>
            <option value="4">A BA degree or higher</option>
          </select>

          <label for="hispanic">Hispanic:</label>
          <select id="hispanic" name="hispanic">
            <option value="0" selected>Regardless of ethnicity</option>
            <option value="1">Hispanic</option>
            <option value="2">Non-Hispanic</option>
          </select>

          <label for="value">Value:</label>
          <select id="val" name="value">
            <option value="percentage" selected>Percentage</option>
            <option value="number">Number</option>
          </select>




        </div>

      </div>
    </div>


    <!--  ---------------
                MAP 
          --------------- -->
    <div class="mapColumn">
      <h10>MAPS</h10>
      <h3 class="withRule">EMPLOYMENT RATE ESTIMATE (2022)</h3>
      <h3 style="color: black">The employment rate for non-institutionalized,
        <span id="gender">male or female</span>,
        with <span id="disabilityType">any</span> disability,
        <span id="age">all ages</span>,
        <span id="race">all races</span>,
        <span id="hispanic">regardless of ethnicity</span>,
        with <span id="education"></span> in the Unites States is <span id="dynamic_p_estimate">13.9%</span> in 2022.
      </h3>
      <div id="restaurant-hover" class="restaurant-hover"></div>
      <svg id="svgMap" width="1000" height="700" top="10">
      </svg>
    </div>

  </div>


  <!-- ==================
        MAP SCRIPT
    =================== -->
  <script id="map">
    const svgMap = d3.select("#svgMap");
    const width = svgMap.attr("width");
    const height = svgMap.attr("height");
    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/ckttxzrvq0s4i18l4he5vtltt/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`

    //set up colors 
    const selectedColor = "#7339D0";
    const greyedoutColor = "#A5A0AC";

    const requestMapData = async () => {

      //initialize dict with column values
      let columnValues = {
        mapType: 0,
        gender: 0,
        disabilityType: 1,
        age: 0,
        race: 0,
        education: 0,
        hispanic: 0,
        value: 0 //TODO: delete this? I think it's a bit redundant
      };


    

      //state data (filter based on selected)
      let statesAll = await d3.csv("./acs_prevalence.csv", d3.autoType);
      let statesData = statesAll.filter(function (row) {
        return (
          row.gender === columnValues.gender
          &&
          row.disability_type === columnValues.disabilityType
          &&
          row.age === columnValues.age &&
          row.race === columnValues.race &&
          row.education === columnValues.education &&
          row.hispanic === columnValues.hispanic
        )
      }); //this is used for filtering



      
      //setting up selections to track selections for prevalence 
      //TODO: need to adapt to different datasets
      let prevalenceColumns = ["mapType", "gender", "disabilityType", "age", "race", "education", "hispanic", "values"];
      prevalenceColumns.forEach((d) => {

        d3.select(`select#${d}`)
          .on("change", function () {
            columnValues[d] = Number(d3.select(this).property("value"));
            //console.log(`${d} changed, logging column values:`, columnValues);

            updateData();
          });
      })

      //these are columns that affect text
      let textColumns = ["gender", "disabilityType", "age", "race", "education", "hispanic"]


      //load map data and match up state names to codes
      const us = await d3.json("./us.json");
      const code_names = await d3.csv("./state-name-codes.csv", d3.autoType);


      // 3b. Generate the data structures we will need
      var stateDict = {}   // stateID ===> stateData

      code_names.forEach(d => {
        stateDict[d.state_code] = d.state_name;
      });

      var dataDict = {}
      statesData.forEach(d => {
        dataDict[d.state] = { n_estimate: d.n_estimate, p_estimate: d.p_estimate }
      });
      //console.log("dataDict", dataDict);

      //create list of p_estimates to calculate extent
      let all_p_estimates = [];

      for (const key in dataDict) {
        if (dataDict.hasOwnProperty(key)) {
          const values = dataDict[key];
          all_p_estimates.push(values.p_estimate);
        }
      }

      //console.log("all_p_estimates", all_p_estimates);
      //updates text for all disability text for usa (this assumes the first selection is everyone with disability)
      d3.select("span#usa_p_estimate").text(`${dataDict["the United States"].p_estimate}%`);

      var states = topojson.feature(us, us.objects.states);     // List of state outlines to fill
      var statesMesh = topojson.mesh(us, us.objects.states);    // 'Mesh' of all outlines put together for a stroke

      //add names to each state
      states.features.forEach(d => {
        d.name = stateDict[d.id]
      });


      // MAP
      const projection = d3.geoMercator() //geoAlbersUsa() to see alaska
        .scale(1 / (2 * Math.PI))
        .translate([0, 0]);

      let render = d3.geoPath(projection);

      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = svgMap.append("g")
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      var data = []; //TODO: update this when data changes, colorScale will also be automatically updated
      let colors = d3.schemeBlues[9];
      let colorScaleState = d3.scaleQuantize(d3.extent(all_p_estimates), colors);

      let statePaths = svgMap.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)  // debugging
        .attr("d", render)
        .attr("fill", d => {
          if (d.name == "Virgin Islands") return "none" //we don't have data for Virgin Islands
          else return colorScaleState(dataDict[d.name].p_estimate)
        })
        .attr("opacity", 0.8)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState);

      let momesh = svgMap.append("path")
        .attr("class", "mouseover outline")
        .style("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .attr("d", "");

      //Mouseover interaction
      let tooltipWidth = 250;
      let tooltipHeight = 45;

      let tooltip = svgMap.append("g")
        .attr("class", "tooltip")
        .attr("transform", `translate(${20},20)`)
        .attr("visibility", "hidden");

      let box = tooltip.append("rect")
        .attr("fill", "white")
        .attr("opacity", 0.8)
        .attr("x", 0)
        .attr("y", 10)
        .attr("width", 110)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 15);
      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 35);

      var state_datum = states.features[0]; //use this to store selected SVG element to use for zooming, initialized with first feature

      let selectedValue = "percentage";
     
      function mouseEntersState() {
      
        d3.select("#val").on("change", function() {
          selectedValue =  d3.select(this).property("value");
          console.log(selectedValue)
        });
      
        // Make tooltip visible
        tooltip.style("visibility", "visible")

        let state = d3.select(this);
        state_datum = state.datum();

        let stateID = state_datum.id;

        txt.text(state_datum.name);
        
        if (selectedValue === "percentage") {
          txt2.text(dataDict[state_datum.name].p_estimate + "%");
        }
        if (selectedValue == "number"){
          txt2.text(dataDict[state_datum.name].n_estimate);

        }
        let bounds = render.bounds(state.datum());
        let xPos = (state_datum.name === "Alaska") ? bounds[0][0] : (bounds[0][0] + bounds[1][0]) / 2;
        let yPos = bounds[1][1];

        tooltip.attr("transform", `translate(${xPos},${yPos})`);

        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });

        momesh.datum(mo).attr("d", render)

      }

      function mouseLeavesState() {

        // Hide when you leave a state
        tooltip.style("visibility", "hidden");

        let state = d3.select(this);

        // Reset old style mouseover stroke
        // state.attr("stroke","none")
        //      .attr("stroke-width", 0);
        // }

        // hiding the mouseover mesh
        momesh.attr("d", "");

      }
      var zoom = d3.zoom()
        .scaleExtent([1 << 12, 1 << 20])
        .on("zoom", ({ transform }) => zoomed(transform));


      //centerLocation
      let centerCoordinates = {
        latitude: 41.4925,
        longitude: -99.9018
      };

      svgMap
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(- 1 << 12)
          .translate(...projection([centerCoordinates.longitude, centerCoordinates.latitude]))
          .scale(-1)
        )
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {
        // console.log("regular projection", projection([42.36541856, -71.05688332]))

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);


          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);

        });

        projection
          .scale(transform.k / (2 * Math.PI))
          .translate([transform.x, transform.y]);

        render = d3.geoPath(projection);

        //update state outlines
        statePaths.attr("d", render);

        //update hover path location
        momesh.attr("d", render);

        //update text location
        let bounds = render.bounds(state_datum);
        let xPos = (state_datum.name === "Alaska") ? bounds[0][0] : (bounds[0][0] + bounds[1][0]) / 2;
        let yPos = bounds[1][1];
        tooltip.attr("transform", `translate(${xPos},${yPos})`);

      };


      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      //calls update on filters when selections are changed
      function updateData() {


        statesData = statesAll.filter(function (row) {
          return (
            row.gender === columnValues.gender
            &&
            row.disability_type === columnValues.disabilityType
            &&
            row.age === columnValues.age &&
            row.race === columnValues.race &&
            row.education === columnValues.education &&
            row.hispanic === columnValues.hispanic
          )
        });
        //console.log(statesData);

        //console.log("dataDict before", dataDict)
        //refilters the states to be displayed
        statesData.forEach(d => {
          dataDict[d.state] = { n_estimate: d.n_estimate, p_estimate: d.p_estimate }
        });
        //console.log("dataDict after", dataDict)

        //TODO: should we rescale to show more color ranges, or keep for consistency?
        all_p_estimates = [];

        // reevaluate all p_estimates
        for (const key in dataDict) {
          if (dataDict.hasOwnProperty(key)) {
            const values = dataDict[key];
            // Add value2 to the allValue2s array
            all_p_estimates.push(values.p_estimate);
          }
        }

        console.log("usa p est: ", dataDict["the United States"])


        colorScaleState = d3.scaleQuantize(d3.extent(all_p_estimates), colors);

        statePaths.attr("fill", d => {
          if (d.name == "Virgin Islands") return "none" //we don't have data for Virgin Islands
          else return colorScaleState(dataDict[d.name].p_estimate)
        })

        //dynamically fill description spans
        textColumns.forEach(d => {
          let value = key[d][Number(columnValues[d])];
          d3.select(`span#${d}`).text(value);
        })
        d3.select("span#dynamic_p_estimate").text(`${dataDict["the United States"].p_estimate}%`);


      }

      updateData();

    }

    requestMapData();

    // ---------------
    // HELPER FUNCTIONS
    // ---------------

    //key to match numbers to names, used to dynamically populate descriptions
    let key = {
      gender: {
        0: 'male or female',
        1: 'male',
        2: 'female'
      },
      disabilityType: {
        1: 'any',
        2: 'visual',
        3: 'hearing',
        4: 'ambulatory',
        5: 'cognitive',
        6: 'self-care',
        7: 'independent living'
      },
      age: {
        0: 'all ages',
        1: 'ages 4 and under',
        2: 'ages 5-15',
        3: 'ages 16-20',
        4: 'ages 21-64',
        5: 'ages 16-64',
        6: 'ages 18-64',
        7: 'ages 65-74',
        8: 'ages 65+',
        9: 'ages Ages 75+'
      },
      race: {
        0: 'all races',
        1: 'White',
        2: 'Black/African American',
        3: 'Native American or Alaska native',
        4: 'Asian',
        5: 'some other race(s)'
      },
      education: {
        0: 'all education levels',
        1: 'less than a high school education',
        2: 'a high school diploma or equivalent',
        3: 'some college/associates degree',
        4: 'a BA degree or higher'
      },
      hispanic: {
        0: 'regardless of ethnicity',
        1: 'Hispanic',
        2: 'non-Hispanic'
      },
    }

    //makes sure element shows up within bounds
    function elementLocation(mouseX, mouseY, elementWidth, elementHeight, boundaryX, xMargin, yMargin) {

      let xPos = mouseX + xMargin;
      let yPos = mouseY - yMargin - elementHeight;

      if ((xPos + elementWidth) > boundaryX) {
        xPos = mouseX - xMargin - elementWidth
      }
      if (yPos < 0) {
        yPos = mouseY - yMargin
      }

      return { x: xPos, y: yPos };

    }



  </script>

</body>